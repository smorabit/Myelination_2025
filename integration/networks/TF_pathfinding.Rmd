
```{r eval=FALSE}
library(Seurat)
library(Signac)
library(tidyverse)
library(RColorBrewer)
library(viridis)
library(cowplot)
library(ggrepel)
library(ggrastr)
library(hdWGCNA)
theme_set(theme_cowplot())
set.seed(12345)

setwd("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF")
data_dir <- 'processed/'
fig_dir <- 'figures/'

# set the current cell-type (oligos)
cur_celltype <- 'ODC'
fig_dir <- paste0('figures/', cur_celltype, '/'); dir.create(fig_dir)

################################################################################
# load Seurat objects
################################################################################

# load the co-embedding object for the oligo lineage:
seurat_obj <- readRDS('/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/seurat_objects/ODC_coembed_seurat.rds')

# add umap coords:
seurat_obj@meta.data$UMAP_1 <- seurat_obj@reductions$umap@cell.embeddings[,1]
seurat_obj@meta.data$UMAP_2 <- seurat_obj@reductions$umap@cell.embeddings[,2]

# load the ATAC & RNA objects separately, and subset just by the oligo lineage cells:
seurat_atac <- readRDS('/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/seurat_objects/snATAC_processed_seurat.rds')
DefaultAssay(seurat_atac) <- 'peaks'
seurat_atac$Time.point <- seurat_atac$Timepoint

# load RNA object
seurat_rna <- readRDS("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/seurat_objects/snRNA_processed_seurat.rds")

# load old & young t-degs
o_tdegs <- read.csv('/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/ODC_Old_tDEGs.csv')
rownames(o_tdegs) <- o_tdegs$gene_id

y_tdegs <- read.csv('/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/ODC_Young_tDEGs.csv')
rownames(y_tdegs) <- y_tdegs$gene_id

################################################################################
# subset old/young:
################################################################################

cur_group <- 'Young'
cur_group <- 'Old'

# re-load the trajectory information
load(file=paste0("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/", cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

subset.cells <- ((seurat_obj$Time.point == 'Naive' & seurat_obj$subcluster_name == 'OPC') |
(seurat_obj$Time.point == 'Day.5' & seurat_obj$subcluster_name %in% c('OPC', 'NFOL')) |
(seurat_obj$Time.point == 'Day.14' & seurat_obj$subcluster_name %in% c('MF-ODC', 'Int-ODC')) |
(seurat_obj$Time.point == 'Day.30' & seurat_obj$subcluster_name == 'Mat-ODC')) &
(seurat_obj$Group == cur_group)
table(subset.cells)

# subset the seurat obj
seurat_subset <- seurat_obj[,subset.cells]

# cut pseudotime into bins:
seurat_subset <- hdWGCNA:::BinPseudotime(seurat_subset, n_bins=c(10,50,100))

# re-load gl-cCRE table:
link_df <- read.csv(file=paste0("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/", cur_celltype, '_', cur_group, '_gl-cCREs.csv'))

peak1_ranges <- Signac::StringToGRanges(link_df$Peak1, sep=c('-', '-'))
peak1_ranges$peak <- link_df$Peak1

peak2_ranges <- Signac::StringToGRanges(link_df$Peak2, sep=c('-', '-'))
peak2_ranges$peak <- link_df$Peak2

```


TF pathfinding 

```{r eval=FALSE}

library(igraph)
library(tidygraph)
library(ggraph)
library(hdWGCNA)

# define the grey genes
modules_oligo <- GetModules(seurat_hd, wgcna_name = 'oligo')
modules_opc <- GetModules(seurat_hd, wgcna_name = 'opc')
grey_genes <- unique(c(
  subset(modules_oligo, module == 'grey') %>% .$gene_name,
  subset(modules_opc, module == 'grey') %>% .$gene_name
))

expressed_genes <- GetWGCNAGenes(seurat_rna)
length(expressed_genes)

# define the number of pseudotime bins
nbins <- 50

pathfinding_tfs <- list()
cur_group <- 'Young'; plot_colors <- c('seagreen', 'seagreen3')
cur_group <- 'Old'; plot_colors <- c('darkorchid3', 'mediumorchid1')

load(file=paste0("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/", cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

importance_df <- read.csv(file=paste0("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/", cur_celltype, '_', cur_group, '_xgboost_importance.csv') )

target_df <- read.csv(file=paste0("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/", cur_celltype, '_', cur_group, '_tf_target_df.csv') ) %>% dplyr::select(-X)

regulon_scores_pos <- read.table(
  file=paste0("/home/groups/singlecell/smorabito/PhD_ongoing/AMRF/processed/", cur_celltype, '_', cur_group, '_tf_regulon_scores_pos.csv'),
  sep=',', header=TRUE, row.names=1
)

critical_nodes <- c('Sox10', 'Nkx2-2', 'Nkx6-2', 'Tcf4', 'Olig1', 'Olig2')

tfs <- as.character(tf_z_df$gene)

target_df <- subset(target_df, source %in% tfs)

full_tf_z_df <- tf_z_df
tf_z_df <- subset(full_tf_z_df, gene %in% tfs)

# add bins to the target_df
ix <- match(target_df$source, as.character(z_df$gene))
target_df$source_bin <- z_df$bin[ix]
ix <- match(target_df$target, as.character(z_df$gene))
target_df$target_bin <- z_df$bin[ix]
target_df$bin_dist <- (1 + abs(target_df$source_bin - target_df$target_bin)) / nbins

# update weights based on binding sites:
bs_weights <- c(1, 0.75, 0.5); names(bs_weights) <- c('Both', 'Promoter', 'Enhancer')
ix <- match(target_df$bs_group, names(bs_weights))
target_df$bs_weight <- bs_weights[ix]
target_df$pair <- paste0(as.character(target_df$source), '_', as.character(target_df$target))
importance_df$pair <- paste0(as.character(importance_df$source), '_', as.character(importance_df$target))
target_df <- subset(target_df, pair %in% importance_df$pair)
ix <- match(target_df$pair, importance_df$pair)
target_df$Gain <- importance_df$Gain[ix]
target_df$exp_cor <- importance_df$exp_cor[ix]
low_gain <- min(target_df$Gain[target_df$Gain != 0])
target_df$Gain_orig <- target_df$Gain
target_df$Gain <- ifelse(target_df$Gain == 0, low_gain, target_df$Gain)
target_df$weight <- (target_df$bin_dist) / (target_df$cor + target_df$bs_weight + target_df$Gain)


target_df <- target_df %>% 
  subset(!(target %in% grey_genes)) %>% subset(!(source %in% grey_genes))

# set up directed graph comprising only TFs (g1)
edge_df <- target_df %>% subset(target %in% tfs & weight > 0)
valid_tfs <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% valid_tfs) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))
g1 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)

#set up directed graph with TFs + all target genes:
edge_df <- target_df; genes.keep <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% genes.keep) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))
g2 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)

################################################################################
# TF-TF network pathfinding analysis
################################################################################

igraph::degree(g1,  v = V(g1)[V(g1)$name %in% tfs], mode='out')

lay <- as.matrix(cbind(V(g1)$Z1, V(g1)$Z2))
rownames(lay) <-  V(g1)$name

colr <- plasma(100)
ix <- round(scales::rescale(V(g1)$rank, to = c(1, 100)))
V(g1)$color <- colr[ix]

selected_genes <- c(critical_nodes)
# selected_genes <-
V(g1)$label <- ifelse(V(g1)$name %in% selected_genes, V(g1)$name, '')

# to select these nodes, should I change the start / end to all TFs in the first or last bins?
start_nodes <- tf_z_df %>% 
  subset(gene %in% names(V(g1))) %>%
  subset(bin < 4 & gene %in% expressed_genes) %>% .$gene %>% as.character
end_nodes <- tf_z_df %>% 
  subset(gene %in% names(V(g1))) %>%
  subset(bin > 45  & gene %in% expressed_genes) %>% .$gene %>% as.character



vpath_list <- list()
epath_list <- c()

# paths between critical node and end nodes
for(cur_node in critical_nodes){
  print(cur_node)
  for(cur_end in end_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}

# paths between start node and end nodes
for(cur_node in start_nodes){
  print(cur_node)
  for(cur_end in end_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}

# paths between start node and critical nodes
for(cur_node in start_nodes){
  print(cur_node)
  for(cur_end in critical_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}

# get all the vertices:
vertices <- unique(unlist(lapply(vpath_list, function(x){x$name})))
vertices[!(vertices %in% start_nodes | vertices %in% end_nodes | vertices %in% critical_nodes)]
pathfinding_tfs[[cur_group]] <- vertices

#-----------------------------------------------------------#
# Plotting with tidygraph
#-----------------------------------------------------------#

# get all the edges: (edges are stored as numeric edge ids)
edges <- unlist(epath_list)

# subset edges:
sub_g1 <- subgraph.edges(g1, edges)
vertices <- V(sub_g1)$name
print(length(E(sub_g1)))
print(length(V(sub_g1)$name))
vertices[!(vertices %in% V(sub_g1)$name)]


V(sub_g1)$degree <- igraph::degree(sub_g1)
V(sub_g1)$indegree <- igraph::degree(sub_g1, mode='in')
V(sub_g1)$outdegree <- igraph::degree(sub_g1, mode='out')


if(cur_group == 'Young'){
  lay <- as.matrix(cbind(V(sub_g1)$Z1, -1 * V(sub_g1)$Z2))
} else{
  lay <- as.matrix(cbind(V(sub_g1)$Z1, V(sub_g1)$Z2))
}

rownames(lay) <-  V(sub_g1)$name
lay <- ggraph::create_layout(sub_g1, lay)


# add shape info based on start, end, critical, and internal nodes
lay$group <- ifelse(lay$name %in% start_nodes, "start", "internal")
lay$group <- ifelse(lay$name %in% end_nodes, "end", lay$group)
lay$group <- ifelse(lay$name %in% critical_nodes, "critical", lay$group)

shapes <- c(23, 24, 22, 21)
names(shapes) <- c('critical', 'start', 'end', 'internal')

#-----------------------------------------------------------#
# Plot with all TFs in the background 
#-----------------------------------------------------------#

p <- ggraph(lay) +
  ggrastr::rasterise(geom_point(
    data = subset(z_df, !(gene %in% grey_genes)), inherit.aes=FALSE,
    aes(x = Z1, y = Z2, color=rank), 
    #color='grey', 
    size=1, alpha=0.1
  ), dpi=300) +
  ggrastr::rasterise(geom_edge_link(
    aes(alpha = log(weight)),
    color = 'lightgrey',
    arrow = arrow(length = unit(1, 'mm'), type='closed'),
    linewidth=0.25
  ), dpi=300) + 
  ggrastr::rasterise(
    geom_node_point(aes(fill=rank, size=degree, shape=group, color=rank)),
    dpi = 300) + 
  scale_shape_manual(values=shapes) +   scale_fill_gradientn(colors=viridis::plasma(256)) + 
  scale_color_gradientn(colors=viridis::plasma(256)) + 
  guides(
      edge_alpha="none", 
      size = "none",
      shape = "none",
      fill = "none",
      color = "none"
  ) 


pdf(paste0(fig_dir, cur_group, '_tf_netplot_bg_nolabel_ggraph.pdf'), width=7, height=7)
p 
dev.off()

#-----------------------------------------------------------#
# Label some of the nodes w/ most connections?
#-----------------------------------------------------------#

label_nodes <- critical_nodes

label_nodes <- c(
  label_nodes, 
  lay %>% subset(group == 'start') %>% slice_max(n=3, order_by=outdegree) %>% .$name
)
label_nodes <- c(
  label_nodes,
  lay %>% subset(group == 'end') %>% slice_max(n=3, order_by=indegree) %>% .$name
)
label_nodes <- c(
  label_nodes,
  lay %>% subset(group == 'internal') %>% slice_max(n=5, order_by=degree) %>% .$name
)
 

p <- ggraph(lay) +
  ggrastr::rasterise(geom_point(
    data = subset(z_df, !(gene %in% grey_genes)), inherit.aes=FALSE,
    aes(x = Z1, y = Z2, color=rank), 
    #color='grey', 
    size=0.1, alpha=0.2
  ), dpi=300) +
  ggrastr::rasterise(geom_edge_link(
    aes(alpha = log(weight)),
    color = 'lightgrey',
    arrow = arrow(length = unit(1, 'mm'), type='closed'),
    linewidth=0.25
  ), dpi=300) + 
  geom_node_point(aes(fill=rank, size=degree, shape=group), color='black') + 
  scale_shape_manual(values=shapes) +   scale_fill_gradientn(colors=viridis::plasma(256)) + 
  scale_size(range = c(3,10)) +
  geom_node_label(
    data = subset(lay, name %in% label_nodes),
    aes(label = name), repel=TRUE, max.overlaps=Inf, fontface='italic'
  ) + 
  scale_color_gradientn(colors=viridis::plasma(256)) + 
  guides(
      edge_alpha="none", 
      size = "none",
      shape = "none",
      fill = "none",
      color = "none"
  ) 


pdf(paste0(fig_dir, cur_group, '_tf_netplot_bg_ggraph.pdf'), width=6, height=6)
p 
dev.off()


#-----------------------------------------------------------#
# Plot some of the individual paths 
#-----------------------------------------------------------#

for(i in 1:length(epath_list)){

  cur_path <- epath_list[[i]]
  cur_vpath <- vpath_list[[i]]
  cur_vpath_ix <- as.numeric(cur_vpath)
  path_nodes <- V(g1)$name[cur_vpath_ix]
  path_start <- path_nodes[1]
  path_end <- path_nodes[length(path_nodes)]
  path_name_full <- paste(path_nodes, collapse=' --> ')
  path_name <- paste(c(path_start, path_end), collapse = ' --> ')
  p
  if(sum(path_nodes %in% validation_tfs) > 1){
        print(i)
  }
}

for(i in 1:length(epath_list)){

  cur_path <- epath_list[[i]]
  cur_vpath <- vpath_list[[i]]
  cur_vpath_ix <- as.numeric(cur_vpath)
  path_nodes <- V(g1)$name[cur_vpath_ix]
  path_start <- path_nodes[1]
  path_end <- path_nodes[length(path_nodes)]
  path_name_full <- paste(path_nodes, collapse=' --> ')
  path_name <- paste(c(path_start, path_end), collapse = ' --> ')

  if((sum(path_nodes %in% validation_tfs) > 1) & (length(path_nodes) > 3)){

    print(path_name_full)

    # subset edges:
    sub_path <- subgraph.edges(g1, cur_path)
    vertices <- V(sub_path)$name

    V(sub_path)$degree <- igraph::degree(sub_path)
    V(sub_path)$indegree <- igraph::degree(sub_path, mode='in')
    V(sub_path)$outdegree <- igraph::degree(sub_path, mode='out')


    # create the ggraph layout

    # reverse the y-axis (young only)
    if(cur_group == 'Young'){
      lay_path <- as.matrix(cbind(V(sub_path)$Z1, -1 * V(sub_path)$Z2))
    } else{
      lay_path <- as.matrix(cbind(V(sub_path)$Z1, V(sub_path)$Z2))
    }

    rownames(lay_path) <-  V(sub_path)$name
    lay_path <- ggraph::create_layout(sub_path, lay_path)

    # add shape info based on start, end, critical, and internal nodes
    lay_path$group <- ifelse(lay_path$name %in% critical_nodes, 'critical', 'internal')
    lay_path$group <- ifelse(lay_path$indegree == 0, "start", lay_path$group)
    lay_path$group <- ifelse(lay_path$outdegree == 0, "end", lay_path$group)

    shapes <- c(23, 24, 22, 21)
    names(shapes) <- c('critical', 'start', 'end', 'internal')

    # zoom in on the boundaries:
    extend_range <- 0.2
    x_min <- min(lay_path$x)
    x_max <- max(lay_path$x)
    y_min <- min(lay_path$y)
    y_max <- max(lay_path$y)

    # how to make it a square?
    y_length <- (y_max - y_min) 
    x_length <- (x_max - x_min)
    if(x_length > y_length){
      diff <- (x_length - y_length) / 2
      y_min <- y_min - diff - extend_range
      y_max <- y_max + diff + extend_range
      x_min <- x_min - extend_range 
      x_max <- x_max + extend_range
    } else{
      diff <- (y_length - x_length) / 2
      x_min <- x_min - diff - extend_range
      x_max <- x_max + diff + extend_range
      y_min <- y_min - extend_range 
      y_max <- y_max + extend_range
    }


    # make the full network plot w/ the box on top of the zoomed in part 
    p1 <- ggraph(lay_path) +
      ggrastr::rasterise(geom_point(
        data = subset(z_df, !(gene %in% grey_genes)), inherit.aes=FALSE,
        aes(x = Z1, y = Z2, color=rank), 
        #color='grey', 
        size=0.1, alpha=0.2
      ), dpi=300) +
      geom_edge_link(
        color = 'black',
        arrow = arrow(length = unit(2, 'mm'), type='closed'),
        end_cap = circle(1.5, 'mm'),
        linewidth=0.5
      ) + 
      geom_node_point(aes(shape=group), color='black', size=3, fill=lay_path$color) + 
      scale_shape_manual(values=shapes) +  
      # scale_fill_gradientn(colors=viridis::plasma(256)) + 
      scale_color_gradientn(colors=viridis::plasma(256)) + 
      annotate(
        "rect", 
        xmin = x_min, ymin = y_min, 
        xmax = x_max, ymax = y_max, 
        fill=NA, color='black', linewidth=0.5
      ) +
      guides(
          edge_alpha="none", 
          size = "none",
          shape = "none",
          fill = "none",
          color = "none"
      ) 

    # make the zoomed in plot 
    p2 <- ggraph(lay_path) +
      ggrastr::rasterise(geom_point(
        data = subset(z_df, !(gene %in% grey_genes)), inherit.aes=FALSE,
        aes(x = Z1, y = Z2, color=rank), 
        #color='grey', 
        size=2, alpha=0.2
      ), dpi=300) +
      geom_edge_link(
        color = 'black',
        arrow = arrow(length = unit(2, 'mm'), type='closed'),
        end_cap = circle(3, 'mm'),
        linewidth=0.5
      ) + 
      geom_node_point(aes(shape=group), color='black', size=6, fill=lay_path$color) + 
      scale_shape_manual(values=shapes) + 
      # scale_fill_gradientn(colors=viridis::plasma(256)) + 
      geom_node_text(
        aes(label = name), repel=TRUE, max.overlaps=Inf, fontface='italic'
      ) + 
      scale_color_gradientn(colors=viridis::plasma(256)) + 
      xlim(c(x_min, x_max)) + 
      ylim(limits = c(y_min, y_max)) +
      guides(
          edge_alpha="none", 
          size = "none",
          shape = "none",
          fill = "none",
          color = "none"
      ) 

    patch <- (p1 + p2) + plot_annotation(title = path_name)

    pdf(paste0(fig_dir, 'select_paths/', cur_group, '_', path_name_full, '.pdf'), width=6, height=3)
    print(patch)
    dev.off()

    pdf(paste0(fig_dir, 'select_paths/', cur_group, '_', path_name_full, '_zoom.pdf'), width=3, height=3)
    print(p2)
    dev.off()

  }
}

#-----------------------------------------------------------#
# Plot some of the individual paths 
#-----------------------------------------------------------#

tf_list <- c('Bach2', 'Sox8', 'Elf2', 'Bhlhe41', 'Nr6a1', 'Stat3', 'Foxk2')

# maybe there's some issue with the colors of the points in the path?

# this one looks cool
for(i in 1:length(epath_list)){

  cur_path <- epath_list[[i]]
  cur_vpath <- vpath_list[[i]]
  cur_vpath_ix <- as.numeric(cur_vpath)
  path_nodes <- V(g1)$name[cur_vpath_ix]
  path_start <- path_nodes[1]
  path_end <- path_nodes[length(path_nodes)]
  path_name_full <- paste(path_nodes, collapse=' --> ')
  path_name <- paste(c(path_start, path_end), collapse = ' --> ')

  if(any(path_nodes %in% tf_list) & (length(path_nodes) > 3) & (sum(path_nodes %in% validation_tfs) > 1)){

    print(path_name_full)
    #cur_path <- epath_list[[2]]

    # subset edges:
    sub_path <- subgraph.edges(g1, cur_path)
    vertices <- V(sub_path)$name

    V(sub_path)$degree <- igraph::degree(sub_path)
    V(sub_path)$indegree <- igraph::degree(sub_path, mode='in')
    V(sub_path)$outdegree <- igraph::degree(sub_path, mode='out')


    # create the ggraph layout

    # reverse the y-axis (young only)
    if(cur_group == 'Young'){
      lay_path <- as.matrix(cbind(V(sub_path)$Z1, -1 * V(sub_path)$Z2))
    } else{
      lay_path <- as.matrix(cbind(V(sub_path)$Z1, V(sub_path)$Z2))
    }

    rownames(lay_path) <-  V(sub_path)$name
    lay_path <- ggraph::create_layout(sub_path, lay_path)

    print(lay_path$name)


    # add shape info based on start, end, critical, and internal nodes
    lay_path$group <- ifelse(lay_path$name %in% critical_nodes, 'critical', 'internal')
    lay_path$group <- ifelse(lay_path$indegree == 0, "start", lay_path$group)
    lay_path$group <- ifelse(lay_path$outdegree == 0, "end", lay_path$group)

    shapes <- c(23, 24, 22, 21)
    names(shapes) <- c('critical', 'start', 'end', 'internal')


    # zoom in on the boundaries:
    # There's a problem with this code, it has problems if x_min is positive or if x_max is negative.
    extend_range <- 0.2
    x_min <- min(lay_path$x)
    x_max <- max(lay_path$x)
    y_min <- min(lay_path$y)
    y_max <- max(lay_path$y)

    # how to make it a square?
    y_length <- (y_max - y_min) 
    x_length <- (x_max - x_min)
    if(x_length > y_length){
      diff <- (x_length - y_length) / 2
      y_min <- y_min - diff - extend_range
      y_max <- y_max + diff + extend_range
      x_min <- x_min - extend_range 
      x_max <- x_max + extend_range
    } else{
      diff <- (y_length - x_length) / 2
      x_min <- x_min - diff - extend_range
      x_max <- x_max + diff + extend_range
      y_min <- y_min - extend_range 
      y_max <- y_max + extend_range
    }


    # make the full network plot w/ the box on top of the zoomed in part 
    p1 <- ggraph(lay_path) +
      ggrastr::rasterise(geom_point(
        data = subset(z_df, !(gene %in% grey_genes)), inherit.aes=FALSE,
        aes(x = Z1, y = Z2, color=rank), 
        #color='grey', 
        size=0.1, alpha=0.2
      ), dpi=300) +
      geom_edge_link(
        color = 'black',
        arrow = arrow(length = unit(2, 'mm'), type='closed'),
        end_cap = circle(1.5, 'mm'),
        linewidth=0.5
      ) + 
      geom_node_point(aes(shape=group), color='black', size=3, fill=lay_path$color) + 
      scale_shape_manual(values=shapes) +  
      # scale_fill_gradientn(colors=viridis::plasma(256)) + 
      scale_color_gradientn(colors=viridis::plasma(256)) + 
      annotate(
        "rect", 
        xmin = x_min, ymin = y_min, 
        xmax = x_max, ymax = y_max, 
        fill=NA, color='black', linewidth=0.5
      ) +
      guides(
          edge_alpha="none", 
          size = "none",
          shape = "none",
          fill = "none",
          color = "none"
      ) 

    # make the zoomed in plot 
    p2 <- ggraph(lay_path) +
      ggrastr::rasterise(geom_point(
        data = subset(z_df, !(gene %in% grey_genes)), inherit.aes=FALSE,
        aes(x = Z1, y = Z2, color=rank), 
        #color='grey', 
        size=2, alpha=0.2
      ), dpi=300) +
      geom_edge_link(
        color = 'black',
        arrow = arrow(length = unit(2, 'mm'), type='closed'),
        end_cap = circle(3, 'mm'),
        linewidth=0.5
      ) + 
      geom_node_point(aes(shape=group), color='black', size=6, fill=lay_path$color) + 
      scale_shape_manual(values=shapes) + 
      # scale_fill_gradientn(colors=viridis::plasma(256)) + 
      geom_node_text(
        aes(label = name), repel=TRUE, max.overlaps=Inf, fontface='italic'
      ) + 
      scale_color_gradientn(colors=viridis::plasma(256)) + 
      xlim(c(x_min, x_max)) + 
      ylim(limits = c(y_min, y_max)) +
      guides(
          edge_alpha="none", 
          size = "none",
          shape = "none",
          fill = "none",
          color = "none"
      ) 

    patch <- (p1 + p2) + plot_annotation(title = path_name)

    pdf(paste0(fig_dir, 'select_paths/', cur_group, '_', path_name_full, '.pdf'), width=6, height=3)
    print(patch)
    dev.off()

    pdf(paste0(fig_dir, 'select_paths_validation/', cur_group, '_', path_name_full, '_zoom.pdf'), width=3, height=3)
    print(p2)
    dev.off()

  }
}

#-----------------------------------------------------------#
# Plot the expression (and regulon) trajectories for these TFs
#-----------------------------------------------------------#

# options 
point_size <- NA
line_size <- 1
ps_bin_name <- 'pseudotime_bins_50'

# TODO: Just plot this in the Old / Young dataset?
cur_bcs <- subset(seurat_rna@meta.data, Group == cur_group) %>% rownames()

# which regulon scores to use?
regulon_scores <- regulon_scores_pos
regulon_scores <- regulon_scores[cur_bcs,]

# name of the TFs to plot:
cur_tfs <- lay_path$name

# combine the metadata with the TF scores
meta <- seurat_rna@meta.data[cur_bcs,]
plot_df <- cbind(meta, regulon_scores[,cur_tfs])

# compute the average ME in each pseudotime bin
avg_scores <- plot_df %>%
        group_by(get(ps_bin_name)) %>%
        select(all_of(cur_tfs)) %>%
        summarise_all(mean)
for(cur_tf in cur_tfs){
  avg_scores[,cur_tf] <- scale01(avg_scores[,cur_tf])
}

colnames(avg_scores)[1] <- 'bin'
avg_df <- reshape2::melt(avg_scores)
avg_df$bin <- as.numeric(avg_df$bin)
avg_df$type <- 'Regulon'

# combine the metadata with the TF scores
X <- GetAssayData(seurat_rna, slot='data')[cur_tfs, cur_bcs] %>% t()
plot_df <- cbind(meta, X)

# compute the average ME in each pseudotime bin
avg_scores <- plot_df %>%
        group_by(get(ps_bin_name)) %>%
        select(all_of(cur_tfs)) %>%
        summarise_all(mean)
for(cur_tf in cur_tfs){
  avg_scores[,cur_tf] <- scale01(avg_scores[,cur_tf])
}

colnames(avg_scores)[1] <- 'bin'
exp_df <- reshape2::melt(avg_scores)
exp_df$bin <- as.numeric(exp_df$bin)
exp_df$type <- 'Gene'

# combine expression + Regulon:
plot_df <- rbind(exp_df, avg_df)

p <- ggplot(
            plot_df,
            aes(x = bin, y=value, color=type, fill=type)
        ) + 
        geom_point(size=point_size) + 
        geom_smooth(size=line_size, se=FALSE, linewidth=0.5) + 
        scale_color_manual(values=plot_colors) +
        scale_fill_manual(values=plot_colors) +
        xlab('') + 
        ylab('Scaled expression') + 
        theme(
            axis.ticks.x = element_blank(),
            axis.text.x = element_blank(), 
            axis.line.x = element_blank(),
            axis.line.y = element_blank(),
            panel.border = element_rect(size=1, fill=NA, color='black')
        ) 

patch1 <- p + facet_wrap(~variable, ncol=length(validation_tfs))

pdf(paste0(fig_dir, cur_group, '_tf_netplot_selectpath_trajectories.pdf'), width=10, height=2)
print(patch1)
dev.off()



```