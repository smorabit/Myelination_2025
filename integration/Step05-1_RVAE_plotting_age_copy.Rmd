
```{r eval=FALSE}

# conda activate cicero
library(Seurat)
library(Signac)
library(tidyverse)
library(RColorBrewer)
library(viridis)
library(cowplot)
library(ggrepel)
library(ggpubr)
library(monocle3)
library(ggrastr)
library(ArchR)
theme_set(theme_cowplot())
set.seed(12345)
setwd("/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC")

# scp R/* hpc3:/dfs7/swaruplab/smorabit/analysis/galilean/bin/
scripts <- dir("/dfs7/swaruplab/smorabit/analysis/galilean/bin/")
for(script in scripts){
  source(paste0("/dfs7/swaruplab/smorabit/analysis/galilean/bin/", script))
}

data_dir <- 'data/'
fig_dir <- 'figures/'

umap_theme <- theme(
  axis.line=element_blank(),
  axis.text.x=element_blank(),
  axis.text.y=element_blank(),
  axis.ticks=element_blank(),
  axis.title.x=element_blank(),
  axis.title.y=element_blank(),
  panel.background=element_blank(),
  panel.border=element_blank(),
  panel.grid.major=element_blank(),
  panel.grid.minor=element_blank()
)

# set the current cell-type (oligos)
cur_celltype <- 'ODC'

fig_dir <- paste0('figures/', cur_celltype, '/'); dir.create(fig_dir)


################################################################################
# load Seurat objects
################################################################################


# load the color scheme:
load(file='/dfs7/swaruplab/smorabit/collab/AMRF/data/color_scheme.rda')


# load the co-embedding object for the oligo lineage:
seurat_obj <- readRDS('/dfs7/swaruplab/smorabit/collab/AMRF/analysis//ATAC/data/ODC_coembed_seurat.rds')

# add umap coords:
seurat_obj@meta.data$UMAP_1 <- seurat_obj@reductions$umap@cell.embeddings[,1]
seurat_obj@meta.data$UMAP_2 <- seurat_obj@reductions$umap@cell.embeddings[,2]



# load the ATAC & RNA objects separately, and subset just by the oligo lineage cells:
seurat_atac <- readRDS('/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC/data/signac_final_07-02-21.rds')
DefaultAssay(seurat_atac) <- 'peaks'
seurat_atac$Time.point <- seurat_atac$Timepoint

f <- Fragments(seurat_atac)[[1]]
head(f@cells)

# update fragments
samples <- unique(seurat_atac$Sample)
frag_list <- list()
for(i in 1:length(samples)){
  cur_sample <- samples[[i]]
  print(cur_sample)
  cells <- subset(seurat_atac@meta.data, Sample == cur_sample) %>% rownames

  bcs <- do.call(rbind, strsplit(cells, '_'))[, length(strsplit(cur_sample, '_')[[1]]) + 1]
  names(bcs) <- cells

  frag_list[[i]] <- CreateFragmentObject(
    path = paste0("/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC/cellRanger_Fragments/", cur_sample, "/outs/fragments.tsv.gz"),
    cells = bcs,
    validate.fragments=FALSE
  )
}
Fragments(seurat_atac) <- NULL
Fragments(seurat_atac) <- frag_list



seurat_rna <- readRDS("/dfs7/swaruplab/smorabit/collab/AMRF/analysis/snRNAseq/NucSeq_final_doublets_removed_online_inmf_seurat.rds")

atac_ix <- na.omit(match(colnames(seurat_obj), colnames(seurat_atac)))
rna_ix <- na.omit(match(colnames(seurat_obj), colnames(seurat_rna)))

# subset by atac/rna cells that are in the oligo pseudotime object:
seurat_atac_full <- seurat_atac
seurat_rna_full <- seurat_rna

seurat_atac <- seurat_atac_full[,atac_ix]
seurat_rna <- seurat_rna_full[,rna_ix]

# add the co-embed umap to atac/rna objects:
atac_ix <- na.omit(match(colnames(seurat_atac), colnames(seurat_obj)))
rna_ix <- na.omit(match(colnames(seurat_rna), colnames(seurat_obj)))
atac_umap <- seurat_obj@reductions$umap@cell.embeddings[atac_ix,]
rna_umap <- seurat_obj@reductions$umap@cell.embeddings[rna_ix,]
seurat_rna@meta.data <- cbind(seurat_rna@meta.data, seurat_obj@meta.data[rna_ix,c('pseudotime', 'monocle_clusters', 'monocle_partitions', 'pseudotime_bins_10', 'pseudotime_bins_50', 'pseudotime_bins_100')])
seurat_atac@meta.data <- cbind(seurat_atac@meta.data, seurat_obj@meta.data[atac_ix,c('pseudotime', 'monocle_clusters', 'monocle_partitions', 'pseudotime_bins_10', 'pseudotime_bins_50', 'pseudotime_bins_100')])


seurat_atac@reductions$seurat_obj_umap <- CreateDimReducObject(
  embeddings = atac_umap,
  key='UMAP_',
  assay='RNA'
)

seurat_rna@reductions$seurat_obj_umap <- CreateDimReducObject(
  embeddings = rna_umap,
  key='UMAP_',
  assay='RNA'
)

seurat_obj$subcluster_name <- factor(
  as.character(seurat_obj$subcluster_name),
  levels = c('OPC', 'NFOL', 'MF-ODC', 'Int-ODC', 'Mat-ODC')
)

# load snRNA-seq cluster marker genes:
deg_file <- "/dfs7/swaruplab/smorabit/collab/AMRF/analysis/DEGs/data/cluster_markers.csv"
markers <- read.csv(deg_file, stringsAsFactors=FALSE)
markers <- markers %>% subset(group %in% c('NFOL', 'OPC', 'MF-ODC', 'Int-ODC', 'Mat-ODC'))
oligo_markers <- markers %>% .$gene %>% unique


# load old & young t-degs
o_tdegs <- read.csv('/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC/data/ODC_Old_tDEGs.csv')
rownames(o_tdegs) <- o_tdegs$gene_id

y_tdegs <- read.csv('/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC/data/ODC_Young_tDEGs.csv')
rownames(y_tdegs) <- y_tdegs$gene_id

# set archR genome
addArchRGenome("mm10")
addArchRThreads(threads = 8)

# re-load
proj <- loadArchRProject(path = "Franklin_ATAC")
proj@peakSet$site_name <- paste0(
  as.character(seqnames(proj@peakSet)), '-', start(proj@peakSet), '-', end(proj@peakSet)
)
proj@peakSet$peak <- paste0(
  as.character(seqnames(proj@peakSet)), '-',
  as.character(start(proj@peakSet)), '-',
  as.character(end(proj@peakSet))
)
peakset <- data.frame(
  'peak' = proj@peakSet$peak,
  'peakType' = proj@peakSet$peakType,
  'nearestGene' = proj@peakSet$nearestGene
)
rownames(peakset) <- peakset$peak



```


subsetting:

```{r eval=FALSE}

################################################################################
# make an object with young + old together with specified time points
################################################################################

subset.cells <- ((seurat_obj$Time.point == 'Naive' & seurat_obj$subcluster_name == 'OPC') |
(seurat_obj$Time.point == 'Day.5' & seurat_obj$subcluster_name %in% c('OPC', 'NFOL')) |
(seurat_obj$Time.point == 'Day.14' & seurat_obj$subcluster_name %in% c('MF-ODC', 'Int-ODC')) |
(seurat_obj$Time.point == 'Day.30' & seurat_obj$subcluster_name == 'Mat-ODC'))

seurat_subset_both <- seurat_obj[,subset.cells]
table(seurat_subset_both$Group)
seurat_subset_both <- BinPseudotime(seurat_subset_both, n_bins=c(10,50,100))
seurat_subset_both@meta.data$UMAP_1 <- seurat_subset_both@reductions$umap@cell.embeddings[,1]
seurat_subset_both@meta.data$UMAP_2 <- seurat_subset_both@reductions$umap@cell.embeddings[,2]

atac_ix <- na.omit(match(colnames(seurat_subset_both), colnames(seurat_atac)))
rna_ix <- na.omit(match(colnames(seurat_subset_both), colnames(seurat_rna)))

seurat_atac_both <- seurat_atac[,atac_ix]
table(seurat_atac_both$Group)
seurat_rna_both <- seurat_rna[,rna_ix]

################################################################################
# subset old/young:
################################################################################

cur_group <- 'Young'
cur_group <- 'Old'

subset.cells <- ((seurat_obj$Time.point == 'Naive' & seurat_obj$subcluster_name == 'OPC') |
(seurat_obj$Time.point == 'Day.5' & seurat_obj$subcluster_name %in% c('OPC', 'NFOL')) |
(seurat_obj$Time.point == 'Day.14' & seurat_obj$subcluster_name %in% c('MF-ODC', 'Int-ODC')) |
(seurat_obj$Time.point == 'Day.30' & seurat_obj$subcluster_name == 'Mat-ODC')) &
(seurat_obj$Group == cur_group)
table(subset.cells)

# subset the seurat obj
seurat_subset <- seurat_obj[,subset.cells]

# cut pseudotime into bins:
seurat_subset <- BinPseudotime(seurat_subset, n_bins=c(10,50,100))

print(names(seurat_subset@misc))

# add umap coords:
seurat_subset@meta.data$UMAP_1 <- seurat_subset@reductions$umap@cell.embeddings[,1]
seurat_subset@meta.data$UMAP_2 <- seurat_subset@reductions$umap@cell.embeddings[,2]

atac_ix <- na.omit(match(colnames(seurat_subset), colnames(seurat_atac)))
rna_ix <- na.omit(match(colnames(seurat_subset), colnames(seurat_rna)))

seurat_atac <- seurat_atac[,atac_ix]
seurat_rna <- seurat_rna[,rna_ix]

seurat_atac$pseudotime_bins_50 <- seurat_subset@meta.data[seurat_subset$tech == 'atac','pseudotime_bins_50']
seurat_atac$pseudotime_bins_10 <- seurat_subset@meta.data[seurat_subset$tech == 'atac','pseudotime_bins_10']
seurat_rna$pseudotime_bins_50 <- seurat_subset@meta.data[seurat_subset$tech == 'rna','pseudotime_bins_50']
seurat_rna$pseudotime_bins_10 <- seurat_subset@meta.data[seurat_subset$tech == 'rna','pseudotime_bins_10']

# re-load gl-cCRE table:
link_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_gl-cCREs.csv'))
link_df_full <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_full_link_table.csv'))
peak1_ranges <- Signac::StringToGRanges(link_df$Peak1, sep=c('-', '-'))
peak1_ranges$peak <- link_df$Peak1

peak2_ranges <- Signac::StringToGRanges(link_df$Peak2, sep=c('-', '-'))
peak2_ranges$peak <- link_df$Peak2


# proportion plots:
library(patchwork)
library(ggstream)

# compute the proportions
seurat_subset  <- BinProportions(
  seurat_subset, 'pseudotime_bins_50', c('Time.point', 'subcluster_name')
)

# make proportion plots
pl <- PlotBinProportions(
  seurat_subset,
  meta = c('Time.point', 'subcluster_name'),
  pseudotime_bins = 'pseudotime_bins_50',
  arrow_y = -0.16,
  clean=TRUE
)

prop_tp <- pl[[1]] + scale_fill_brewer(palette='PuBu', direction=-1)
prop_ct <- pl[[2]] + scale_fill_manual(values=cluster_colors_rna[as.character(unique(seurat_subset$subcluster_name))])

pdf(paste0(fig_dir,  cur_group, '_test_proportion.pdf'), width=6, height=4)
prop_tp / prop_ct
dev.off()

```

Plot UMAP:

```{r eval=FALSE}

# colored by pseudotime
p1 <- seurat_subset@meta.data %>%
  ggplot(aes(x=UMAP_1, y=UMAP_2, color=pseudotime)) +
  rasterise(geom_point(data=seurat_obj@meta.data, aes(x=UMAP_1, y=UMAP_2), color='grey90', size=0.5), dpi=500) +
  rasterise(geom_point(size=1), dpi=500) +
  scale_color_gradientn(colors=plasma(256)) +
  umap_theme + NoLegend() + ggtitle('Pseudotime') +
  theme(plot.title = element_text(hjust=0.5))


# colored by cluster
p2 <- seurat_subset@meta.data %>%
  ggplot(aes(x=UMAP_1, y=UMAP_2, color=subcluster_name)) +
  rasterise(geom_point(data=seurat_obj@meta.data, aes(x=UMAP_1, y=UMAP_2), color='grey90', size=0.5), dpi=500) +
  rasterise(geom_point(size=1), dpi=500) +
  scale_color_manual(values=cluster_colors_rna[as.character(unique(seurat_subset$subcluster_name))]) +
  umap_theme + ggtitle('Cluster') +
  theme(plot.title = element_text(hjust=0.5))

# colored by Time Point
p3 <- seurat_subset@meta.data %>%
  ggplot(aes(x=UMAP_1, y=UMAP_2, color=Time.point)) +
  rasterise(geom_point(data=seurat_obj@meta.data, aes(x=UMAP_1, y=UMAP_2), color='grey90', size=0.5), dpi=500) +
  rasterise(geom_point(size=1), dpi=500) +
  scale_color_brewer(palette='PuBu', direction=-1) +
  umap_theme + ggtitle('Time point') +
  theme(plot.title = element_text(hjust=0.5))


pdf(paste0(fig_dir, cur_celltype, '_', cur_group, '_trajectory_umap.pdf'), width=13, height=4)
p1 + p2 + p3 + plot_layout(guides='collect')
dev.off()

```

Load stuff for Gviz, only needed for cicero plots

```{r eval=FALSE}

library(EnsDb.Mmusculus.v79)
library(Gviz)
library(cicero)


# load gene annotation for mm10
gene.coords <- genes(EnsDb.Mmusculus.v79, filter = ~ gene_biotype == "protein_coding")
genebody.coords <- keepStandardChromosomes(gene.coords, pruning.mode = 'coarse')
genebodyandpromoter.coords <- Extend(x = genebody.coords, upstream = 2000, downstream = 0)
genebodyandpromoter.coords <- genebodyandpromoter.coords %>% subset(seqnames %in% c(1:20,'Y','X'))

# load .gtf
gtf_file = "/dfs7/swaruplab/smorabit/resources/cellranger-atac_reference/refdata-cellranger-atac-mm10-1.2.0/genes/genes.gtf"
gene_anno <- rtracklayer::readGFF(gtf_file)

# rename some columns to match requirements
gene_anno$chromosome <- gene_anno$seqid
gene_anno$gene <- gene_anno$gene_id
gene_anno$transcript <- gene_anno$transcript_id
gene_anno$symbol <- gene_anno$gene_name

grtrack <- GeneRegionTrack(
  gene.coords, genome = 'mm10', chromosome = 'chr10',
  name = "Gene Model",
  transcriptAnnotation = "symbol",
  background.title = "brown", fill = 'lightgray'
)

```

Plot reconstructed expression heatmap:

```{r eval=FALSE}

library(future.apply)
library(viridis)

# RVAE directory
outdir = '/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC/RVAgene/RVAgene/data/'
#outdir = '/dfs7/swaruplab/smorabit/collab/AMRF/analysis/ATAC/RVAgene/RVAgene/data_old/'
cur_name <- paste0(cur_celltype, '_', cur_group, '_RVAE')
rvagene_csv <- paste0(outdir, 'reconstructed/',cur_name,'_recon.csv')

# seurat_subset <- LoadRVAGeneOutput(
#   seurat_subset,
#   pseudotime_bins = 'pseudotime_bins_50',
#   rvagene_csv = rvagene_csv,
#   name = cur_name
# )
# print(names(seurat_subset@misc$pseudotime_bins_50))

# load reconstructed data and z embedding
dataset = cur_name
recon_df <- read.table(paste0(outdir, 'reconstructed/',cur_name,'_recon.csv'), sep=',', row.names=1, header=TRUE)
z_df <- recon_df[,(ncol(recon_df)-1):ncol(recon_df)]
recon_df <- recon_df[,1:(ncol(recon_df)-2)]
z_df$gene <- rownames(z_df)
dim(z_df)

# scale between 0 & 1
range01 <- function(x){
  cur <- recon_df[x,]
  (cur-min(cur))/(max(cur)-min(cur))
}
scaled <- lapply(rownames(recon_df), range01)
scaled <- do.call(rbind, scaled)
rownames(scaled) <- rownames(recon_df)

#scaled <- recon_df

# order rows by the time they reach 0.75% min expression
exp_thresh <- 0.90
ordering <- future_lapply(1:nrow(scaled), function(i){
  match(names(scaled[i,])[scaled[i,] >= exp_thresh][1], colnames(scaled))
})
ordering <- unlist(ordering)
ordered <- scaled[rownames(scaled)[order(ordering)],]

ordered_bins <- ordering[order(ordering)]

z_df_tmp <- z_df

ix <- match(rownames(z_df), rownames(ordered))
z_df$rank <- ix
z_df$bin <- ordered_bins[ix]
z_df <- dplyr::arrange(z_df, rank)
z_df$gene <- factor(as.character(z_df$gene), levels=as.character(z_df$gene))
all.equal(as.character(z_df$gene), rownames(ordered))


# change colnames of ordered to the bin names:
colnames(ordered) <- levels(seurat_subset$pseudotime_bins_50)

# reverse ordering
# ordered <- ordered[rev(rownames(ordered)),]

#
# melt matrix for plotting:
plot_df <- reshape2::melt(as.matrix( ordered[rev(rownames(ordered)),]))

p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
  rasterise(geom_tile(), dpi=800) +
  scale_fill_viridis() +
  scale_color_viridis() +
  theme(
    plot.margin = margin(0,0,0,0),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )


pdf(paste0(fig_dir, cur_group, '_tDEG_heatmap.pdf'), width=5, height=10)
p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
dev.off()

#
# # compute hierarchical clustering of this matrix:
# library(ggdendro)
# dist_mat <- dist(ordered)
# hc <- hclust(dist_mat, "ave")
#
# # cut tree to get groups
# n_clusters <- 4
# gene_groups <- cutree(hc, k=n_clusters)
# z_df$hclust <- gene_groups
# table(gene_groups)
#
# # get the ordering of each group by median rank
# med_rank <- z_df %>% group_by(hclust) %>%
#   summarise(med=median(rank)) %>%
#   mutate(rank = rev(order(med)))
#
# # re-number the groups based on rank
# z_df$hclust <- med_rank$rank[match( z_df$hclust, med_rank$hclust)]
#
# # make a colorbar for the gene group to put on the side of the heatmap:
# # make the colorbar as its own heatmap
# cluster_colorbar <- z_df %>%
#   ggplot(aes(x=1, y=gene, fill=hclust)) +
#   rasterise(geom_tile(), dpi=800) +
#   scale_fill_gradientn(colors=plasma(5)) +
#   NoLegend() +
#   RotatedAxis() +
#   theme(
#     plot.title=element_blank(),
#     axis.line=element_blank(),
#     axis.ticks=element_blank(),
#     axis.text.y = element_blank(),
#     axis.text.x = element_blank(),
#     axis.title = element_blank(),
#     plot.margin=margin(0,0,0,0)
#   )
#
# pdf(paste0(fig_dir, cur_group, 'tDEG_heatmap_cut.pdf'), width=5, height=10)
# p + cluster_colorbar + plot_layout(widths=c(5,1), guides='collect')
# dev.off()
#
#
#
#
#
# # split into sub-heatmaps by cluster:
# plot_list <- list()
# for(cur in unique(z_df$hclust)){
#   print(cur)
#   cur_genes <- z_df %>% subset(hclust == cur) %>% .$gene %>% as.character
#
#   # melt matrix for plotting:
#   plot_list[[cur]] <- plot_df %>% subset(Var1 %in% cur_genes) %>%
#     ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
#     rasterise(geom_tile(), dpi=800) +
#     scale_fill_viridis() +
#     scale_color_viridis() +
#     theme(
#       plot.margin = margin(0,0,0,0),
#       axis.line.x = element_blank(),
#       axis.line.y = element_blank(),
#       axis.text.x = element_blank(),
#       axis.ticks.x = element_blank(),
#       axis.title.x = element_blank(),
#       axis.text.y = element_blank(),
#       axis.ticks.y = element_blank(),
#       axis.title.y = element_blank()
#     )
# }
#
# plot_heights <- 15 * (table(z_df$hclust) / nrow(z_df))
#
#
#
# pdf(paste0(fig_dir, 'tDEG_', cur_group, '_heatmap2.pdf'), width=5, height=10)
# wrap_plots(plot_list, ncol=1) / prop_tp / prop_ct + plot_layout(heights=c(plot_heights, 1, 1), guides='collect')
# dev.off()
#
#
#
#
#
#
#
# dhc <- as.dendrogram(hc)
# ddata <- dendro_data(dhc, type = "rectangle")
#
# # cut tree to get groups
# cutree(hc, k=5)
#
# p <- ggplot(segment(ddata)) +
#   geom_segment(aes(x = x, y = y, xend = xend, yend = yend)) +
#   coord_flip() +
#   scale_y_reverse(expand = c(0.2, 0))
#
# pdf(paste0(fig_dir, 'tDEG_', cur_group, '_dendro.pdf'), width=5, height=10)
# p
# dev.off()
#
#
#
#
#
# # plot just the t-DEGs that are exclusive to this group:
# select_genes <- setdiff(o_tdegs$gene_id, y_tdegs$gene_id)
# # select_genes <- setdiff(y_tdegs$gene_id, o_tdegs$gene_id)
#
# # melt matrix for plotting:
# plot_df <- reshape2::melt(as.matrix(ordered[rownames(ordered) %in%select_genes,]))
#
# p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
#   rasterise(geom_tile(), dpi=800) +
#   scale_fill_viridis() +
#   scale_color_viridis() +
#   theme(
#     plot.margin = margin(0,0,0,0),
#     axis.line.x = element_blank(),
#     axis.line.y = element_blank(),
#     axis.text.x = element_blank(),
#     axis.ticks.x = element_blank(),
#     axis.title.x = element_blank(),
#     axis.text.y = element_blank(),
#     axis.ticks.y = element_blank(),
#     axis.title.y = element_blank()
#   )
#
#
# pdf(paste0(fig_dir, 'tDEG_', cur_group, '_exclusive_heatmap.pdf'), width=5, height=10)
# p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
# dev.off()

################################################################################
# save useful variables
################################################################################

save(z_df, recon_df, ordered, file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

load(file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

```

Plot genes in Z colored by pseudotime rank

```{r eval=FALSE}


################################################################################
# plot latent space colored by pseudotime rank
################################################################################

library(ggrepel)

theme_set(theme_cowplot())

plot_df <- z_df

p <- plot_df  %>%
  ggplot(aes(Z1, Z2, fill=rank)) +
  geom_point(color=alpha('black', 0), shape=21) +
  scale_fill_gradientn(
    colors=plasma(256),
    guide = guide_colorbar(barwidth=0.5, barheight=5, ticks=FALSE),
    breaks = range(plot_df$rank)
    #labels = c('-', '+'),
  ) + labs(color='') + ggtitle('Gene Trajectory Rank') + theme(plot.title=element_text(hjust=0.5))


pdf(paste0(fig_dir,  cur_group, '_expression_Z_rank_markers.pdf'), width=5, height=5, useDingbats=FALSE)
p + umap_theme
dev.off()



################################################################################
# plot latent space colored by pseudotime rank
################################################################################
library(ggrepel)

theme_set(theme_cowplot())


plot_df <- z_df

p <- plot_df %>% subset(gene %in% switch_genes)  %>%
  ggplot(aes(Z1, Z2, fill=rank)) +
  ggrastr::rasterise(geom_point(inherit.aes=FALSE, data=subset(plot_df, !(gene %in% switch_genes)), aes(Z1,Z2), color='gray', fill='gray', alpha=0.25, size=0.5), dpi=400) +
  geom_point(color=alpha('black', 0), shape=21) +
  scale_fill_gradientn(
    colors=plasma(256),
    guide = guide_colorbar(barwidth=0.5, barheight=5, ticks=FALSE),
    breaks = range(plot_df$rank)
    #labels = c('-', '+'),
  ) + labs(color='') + ggtitle('Gene Trajectory Rank') + theme(plot.title=element_text(hjust=0.5))


pdf(paste0(fig_dir,  cur_group, '_expression_Z_rank_switches.pdf'), width=5, height=5, useDingbats=FALSE)
p + umap_theme
dev.off()



############################
# Correlation with timepoint
##########################

prop_df <- GetBinProportions(seurat_subset, 'Time.point', 'pseudotime_bins_50')
prop_df1 <- prop_df

x <- 'Time.point'
pseudotime_bins <- 'pseudotime_bins_50'
prop_df <- seurat_subset@meta.data %>%
  group_by(get(pseudotime_bins), get(x)) %>%
  summarise(n = n()) %>%
  spread('get(x)', n, fill = 0) %>%
  pivot_longer(levels(seurat_subset@meta.data[[x]])) %>%
  mutate(freq = value / sum(value))
colnames(prop_df)[1:3] <- c('bin', x, 'n')


head(rownames(ordered))
head(rownames(z_df))


plot_list <- list(); i = 1
for(timepoint in c("Naive","Day.5", "Day.14", "Day.30" )){

  # gr <- 'Old'
  #timepoint = 'Day.5'
  #
  print(paste(timepoint))

  prop_cor <- sapply(1:nrow(ordered), function(i){
    cor(as.numeric(ordered[i,]), subset(prop_df, Time.point == timepoint) %>% .$freq)
  })


  plot_df <- z_df
  plot_df$value <- prop_cor

  p <- plot_df %>% arrange(desc(value)) %>%
    ggplot(aes(Z1, Z2, color=value)) +
    ggrastr::rasterise(
      geom_point(size=1),
      dpi=500
    ) +
    scale_color_gradient2(
      low=scales::muted('blue'), mid='gray95', high=scales::muted('red'),
      guide = guide_colorbar(barwidth=0.5, barheight=10, ticks=FALSE)
    ) +
     umap_theme +
    theme(plot.title = element_text(hjust=0.5)) +
    # ggtitle('')
    ggtitle(paste0(cur_group, ', ', gsub('[.]', ' ', timepoint))) +
    coord_fixed(ratio = 1)

    pdf(paste0(fig_dir, 'timepoint_corr/', cur_group, '_', timepoint, '_corr.pdf'), width=5, height=5, useDingbats=FALSE)
    print(p)
    dev.off()

  plot_list[[i]] <- p + NoLegend()
  i <- i+1
}



```

identify switch genes:


```{r eval=FALSE}


load(file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

exp_thresh <- 0.8
switch_thresh <- 2

# number of bins greater than or equal to the thresh
n_bins <- (ordered >= exp_thresh) %>% rowSums

# get switch genes:
switch_genes <- names(which(n_bins <= switch_thresh))

# Old: 2014 genes
length(switch_genes)


# save list for cur group:
save(z_df, recon_df, ordered, switch_genes, file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

# plot just the t-DEGs that are exclusive to this group:
# select_genes <- setdiff(o_tdegs$gene_id, y_tdegs$gene_id)
#select_genes <- setdiff(y_tdegs$gene_id, o_tdegs$gene_id)

# melt matrix for plotting:ff
plot_df <- reshape2::melt(as.matrix(ordered[rownames(ordered) %in% switch_genes,]))

p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
  rasterise(geom_tile(), dpi=800) +
  scale_fill_viridis() +
  scale_color_viridis() +
  theme(
    plot.margin = margin(0,0,0,0),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )


pdf(paste0(fig_dir, cur_group, '_tDEG_switches_heatmap.pdf'), width=5, height=10)
p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
dev.off()



```

Overlap of switch genes:

```{r eval=FALSE}

load(file=paste0(data_dir, cur_celltype, '_Old_expression_trajectory_data.rda'))
old_switches <- switch_genes

load(file=paste0(data_dir, cur_celltype, '_Young_expression_trajectory_data.rda'))
young_switches <- switch_genes



library(eulerr)

overlap_list <- c(
  'Old' = length(setdiff(old_switches, young_switches)),
  'Young' =  length(setdiff(young_switches, old_switches)),
  'Old&Young' =  length(unique(intersect(old_switches, young_switches)))
)


pdf(paste0(fig_dir, 't-DEG_switch_age_overlaps.pdf'), width=4, height=4)
plot(euler(overlap_list), quantities = TRUE)
dev.off()


# melt matrix for plotting:
plot_df <- reshape2::melt(as.matrix(ordered[rownames(ordered) %in% switch_tfs,]))

p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
  rasterise(geom_tile(), dpi=800) +
  scale_fill_viridis() +
  scale_color_viridis() +
  theme(
    plot.margin = margin(0,0,0,0),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )


pdf(paste0(fig_dir, 'tDEG_', cur_group, '_switch_tfs_heatmap.pdf'), width=5, height=10)
p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
dev.off()



```

Setup motif data (important for later steps)

```{r eval=FALSE}

load(file=paste0(data_dir, cur_celltype, '_Old_expression_trajectory_data.rda'))
#old_switches <- switch_genes
old_ordered <- ordered

load(file=paste0(data_dir, cur_celltype, '_Young_expression_trajectory_data.rda'))
#young_switches <- switch_genes
young_ordered <- ordered


# get list of TFs from atac data
DefaultAssay(seurat_atac) <- 'peaks'
chromvar_motifs <- Motifs(seurat_atac)@motif.names %>%
  unlist %>% as.character
print(length(chromvar_motifs))

# set up motif df
motif_df <- data.frame(
  motif_id = names(Motifs(seurat_atac)@motif.names),
  motif_name_orig = as.character(Motifs(seurat_atac)@motif.names)
)

# 1. split apart cases where two genes are one motif delimited by ::
# 2. remove "()" characters and anything within them

tmp <- motif_df$motif_name[grepl("::", motif_df$motif_name)]
tmp_ids <- names(Motifs(seurat_atac)@motif.names[chromvar_motifs %in% tmp])

motif_df$motif_name <- gsub("\\s*\\([^\\)]+\\)","", motif_df$motif_name_orig)
tmp <- motif_df$motif_name[grepl("::", motif_df$motif_name)]
motif_df <- subset(motif_df, !(motif_name %in% tmp))

tmp2 <- strsplit(tmp, '::')
names(tmp2) <- tmp
tmp <- do.call(rbind, lapply(1:length(tmp2), function(i){
  data.frame(motif_id = tmp_ids[i], motif_name_orig = names(tmp2)[i], motif_name = unlist(as.character(tmp2[[i]])))
}))
motif_df <- rbind(motif_df, tmp)

# convert gene names to mouse style by matching genes in ensembl
# motif_df$motif_name <- str_to_title(motif_df$motif_name) # old

# load mouse <-> human gene name table:
hg38_mm10_genes <- read.table(
  "/dfs7/swaruplab/smorabit/resources/hg38_mm10_orthologs_2021.txt",
  sep='\t',
  header=TRUE
)
colnames(hg38_mm10_genes) <-c('hg38_id', 'mm10_id', 'mm10_name', 'hg38_name')
hg38_mm10_genes <- dplyr::select(hg38_mm10_genes, c(hg38_name, mm10_name, hg38_id, mm10_id))

ix <- match(motif_df$motif_name, hg38_mm10_genes$hg38_name)
motif_df$motif_name_mouse <- hg38_mm10_genes$mm10_name[ix]


chromvar_motifs <- unique(motif_df$motif_name_mouse)

# which do we also have RNA data for?
chromvar_motifs <- chromvar_motifs[chromvar_motifs %in% rownames(seurat_rna)]


tf_z_df <- subset(z_df, gene %in% chromvar_motifs)
tf_z_df$motif_id <- motif_df$motif_id[match(tf_z_df$gene, motif_df$motif_name)]


# # which of these are switch genes?
# all_switch_tfs <- chromvar_motifs[chromvar_motifs %in% unique(union(old_switches, young_switches))]
# common_switch_tfs <- chromvar_motifs[chromvar_motifs %in% unique(intersect(old_switches, young_switches))]
# young_switch_tfs <- chromvar_motifs[chromvar_motifs %in% setdiff(young_switches, old_switches)]
# old_switch_tfs <- chromvar_motifs[chromvar_motifs %in% setdiff(old_switches, young_switches)]

################################################################################
# For collaborators:
#
# * send list of switch TFs
# * send list of all TFs in the t-degs regardless of switch
# * send t-deg stats tables
################################################################################

# all tfs in old & young
o_tfs <- chromvar_motifs[chromvar_motifs %in% o_tdegs$gene_id]
y_tfs <- chromvar_motifs[chromvar_motifs %in% y_tdegs$gene_id]


# 1. get t-degs table for TFs
# 2. re-order TF t-degs by pseudotime
# 3. write to file
o_tf_tdegs <- o_tdegs %>% subset(gene_id %in% o_tfs) %>%
  dplyr::select(c(gene_id, estimate))
ix <- rownames(old_ordered)[rownames(old_ordered) %in% o_tf_tdegs$gene_id]
o_tf_tdegs <- o_tf_tdegs[ix,]
write.csv(o_tf_tdegs, file=paste0(data_dir, cur_celltype, '_Old_TF_tDEGs.csv'), quote=FALSE, row.names=FALSE)

y_tf_tdegs <- y_tdegs %>% subset(gene_id %in% y_tfs)  %>%
  dplyr::select(c(gene_id, estimate))
ix <- rownames(young_ordered)[rownames(young_ordered) %in% y_tf_tdegs$gene_id]
y_tf_tdegs <- y_tf_tdegs[ix,]
write.csv(y_tf_tdegs, file=paste0(data_dir, cur_celltype, '_Young_TF_tDEGs.csv'), quote=FALSE, row.names=FALSE)


# for switch tfs:
o_tf_tdegs <- o_tdegs %>% subset(gene_id %in% old_switch_tfs)  %>%
  dplyr::select(c(gene_id, estimate))
ix <- rownames(old_ordered)[rownames(old_ordered) %in% o_tf_tdegs$gene_id]
o_tf_tdegs <- o_tf_tdegs[ix,]
write.csv(o_tf_tdegs, file=paste0(data_dir, cur_celltype, '_Old_TF_switches_tDEGs.csv'), quote=FALSE, row.names=FALSE)

y_tf_tdegs <- y_tdegs %>% subset(gene_id %in% young_switch_tfs)  %>%
  dplyr::select(c(gene_id, estimate))
ix <- rownames(young_ordered)[rownames(young_ordered) %in% y_tf_tdegs$gene_id]
y_tf_tdegs <- y_tf_tdegs[ix,]
write.csv(y_tf_tdegs, file=paste0(data_dir, cur_celltype, '_Young_switches_TF_tDEGs.csv'), quote=FALSE, row.names=FALSE)

################################################################################
# pseudotime trajectory plots for the TFs only:
################################################################################


if(cur_group == "Old"){
  select_genes <- o_tfs; ordered <- old_ordered
} else if(cur_group == "Young"){
  select_genes <- y_tfs; ordered <- young_ordered
}

# melt matrix for plotting:
plot_df <- reshape2::melt(as.matrix(ordered[rownames(ordered) %in% select_genes,]))

p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
  rasterise(geom_tile(), dpi=800) +
  scale_fill_viridis() +
  scale_color_viridis() +
  theme(
    plot.margin = margin(0,0,0,0),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.text.y = element_text(face='italic', size=4),
    axis.title.y = element_blank(),
    plot.title = element_text(hjust=0.5)
  )


pdf(paste0(fig_dir, 'tDEG_', cur_group, '_all_tfs_heatmap.pdf'), width=5, height=10)
p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
dev.off()


```


Set up ordered motif enrichment matrix

```{r eval=FALSE}
#
# # get the average chromvar for each bin, and
# avg_dev <- AverageExpression(seurat_atac, assay='chromvar', slot='data', group.by = 'pseudotime_bins_50')$chromvar
# accessible_peaks <- TopFeaturesInBins(avg_acc, 1, 50, feat_percentile=0.95)
#
# tf_z_df <- subset(z_df, gene %in% chromvar_motifs)
# tf_z_df$motif_id <- motif_df$motif_id[match(tf_z_df$gene, motif_df$motif_name)]
#
# avg_dev <- avg_dev[rownames(avg_dev) %in% tf_z_df$motif_id,]
#
#
# smoothed <- future_lapply(rownames(avg_dev), function(x){
#   print(x)
#   cur <- avg_dev[x,]
#   cur_df <- data.frame(expression=cur, index=1:length(cur))
#   cur_loess <- loess(expression ~ index, data=cur_df, span=0.75)
#   smoothed <- predict(cur_loess)
#   return(smoothed)
# })
# smoothed <- do.call(rbind, smoothed)
# colnames(smoothed) <- colnames(avg_dev)
# rownames(smoothed) <- rownames(avg_dev)
#
# # scale between 0 & 1
# range01 <- function(x){
#   cur <- smoothed[x,]
#   (cur-min(cur))/(max(cur)-min(cur))
# }
# scaled <- lapply(rownames(avg_dev), range01)
# scaled <- do.call(rbind, scaled)
# rownames(scaled) <- rownames(avg_dev)
#
# # order rows by the time they reach max expression
# exp_thresh <- 0.90
# ordering <- future_lapply(1:nrow(scaled), function(i){
#   match(names(scaled[i,])[scaled[i,] >= exp_thresh][1], colnames(scaled))
# })
# ordering <- unlist(ordering)
# ordered_dev <- scaled[rownames(scaled)[order(ordering)],]
#
# ordered_bins <- ordering[order(ordering)]
#
# # reverse ordering
# ordered_dev <- ordered_dev[rev(rownames(ordered_dev)),]
# ix <- match(tf_z_df$motif_id, rownames(ordered_dev))
# tf_z_df$motif_rank <- ix
# tf_z_df$motif_bin <- ordered_bins[ix]
# rownames(ordered_dev) <- tf_z_df$gene[match(rownames(ordered_dev), tf_z_df$motif_id)]
#
# # add the correlation between expression & motif enrichment for each TF:
# tf_z_df$exp_motif_cor <- unlist(lapply(as.character(tf_z_df$gene), function(cur_feat){
#   cor(x = as.numeric(ordered[cur_feat,]),
#       y = as.numeric(ordered_dev[cur_feat,]),
#       method = 'pearson')
# }))
#
# # compute the correlation between each TF and each gene:
# # compute correlation between gene exp and TF enrichment
# dev_cor_mat <- t(cor(
#   t(as.matrix(ordered)),
#   t(as.matrix(ordered_dev)),
#   method='pearson'
# ))
# colnames(dev_cor_mat) <- rownames(ordered)
# rownames(dev_cor_mat) <- rownames(ordered_dev)



ordered_tfs <- ordered[rownames(ordered) %in% tf_z_df$gene,]
tf_cor_mat <- t(cor(
  t(as.matrix(ordered)),
  t(as.matrix(ordered_tfs)),
  method='pearson'
))
colnames(tf_cor_mat) <- rownames(ordered)
rownames(tf_cor_mat) <- rownames(ordered_tfs)
#
# plot_df <- reshape2::melt(as.matrix(ordered_dev))
#
# colfunc <- colorRampPalette(rev(brewer.pal(11, 'Spectral' )))
#
# p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
#   rasterise(geom_tile(), dpi=800) +
#   scale_color_gradientn(colors=colfunc(256)) +
#   scale_fill_gradientn(colors=colfunc(256)) +
#   theme(
#     plot.margin = margin(0,0,0,0),
#     axis.line.x = element_blank(),
#     axis.line.y = element_blank(),
#     axis.text.x = element_blank(),
#     axis.text.y = element_text(face='italic', size=4),
#     axis.ticks.x = element_blank(),
#     axis.title.x = element_blank(),
#     axis.ticks.y = element_blank(),
#     axis.title.y = element_blank()
#   )
#
#
# pdf(paste0(fig_dir, 'tDEG_', cur_group, '_chromvar_heatmap_span.pdf'), width=5, height=10)
# p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
# dev.off()
#

# save(z_df, recon_df, ordered, smoothed, tf_z_df, motif_df, dev_cor_mat, tf_cor_mat, ordered_dev, file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))


save(z_df, recon_df, ordered, tf_z_df, motif_df, tf_cor_mat, file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))




```

Chromatin accessibility of TF promoters:

```{r eval=FALSE}

library(future.apply)

# get the average chromvar for each bin, and
avg_acc <- AverageExpression(seurat_atac_both, assay='peaks', slot='data', group.by = 'pseudotime_bins_50')$peaks

tf_promoters <- proj@peakSet %>%
  subset(nearestGene %in% tf_z_df$gene & peakType == 'Promoter')
names(tf_promoters) <- tf_promoters$site_name
tf_promoters <- tf_promoters  %>% as.data.frame() %>%
  dplyr::select(c(nearestGene, peakType, site_name, distToTSS))

tf_promoters <- tf_promoters %>% group_by(nearestGene) %>% top_n(-1, distToTSS)

avg_acc <- avg_acc[rownames(avg_acc) %in% tf_promoters$site_name,]
rownames(avg_acc) <- tf_promoters$nearestGene


smoothed <- future_lapply(rownames(avg_acc), function(x){
  print(x)
  cur <- avg_acc[x,]
  cur_df <- data.frame(expression=cur, index=1:length(cur))
  cur_loess <- loess(expression ~ index, data=cur_df, span=0.75)
  smoothed <- predict(cur_loess)
  return(smoothed)
})
smoothed <- do.call(rbind, smoothed)
colnames(smoothed) <- colnames(avg_acc)
rownames(smoothed) <- rownames(avg_acc)

# scale between 0 & 1
range01 <- function(x){
  cur <- smoothed[x,]
  (cur-min(cur))/(max(cur)-min(cur))
}
scaled <- lapply(rownames(avg_acc), range01)
scaled <- do.call(rbind, scaled)
rownames(scaled) <- rownames(avg_acc)
scaled[is.na(scaled)] <- 0

# order rows by the time they reach max expression
exp_thresh <- 0.90
ordering <- future_lapply(1:nrow(scaled), function(i){
  match(names(scaled[i,])[scaled[i,] >= exp_thresh][1], colnames(scaled))
})
ordering <- unlist(ordering)
ordered_acc <- scaled[rownames(scaled)[order(ordering)],]

# add the correlation between expression & motif enrichment for each TF:
tmp <- unlist(lapply(as.character(rownames(ordered_acc)), function(cur_feat){
  cor(x = as.numeric(ordered[cur_feat,]),
      y = as.numeric(ordered_acc[cur_feat,]),
      method = 'pearson')
}))
names(tmp) <- rownames(ordered_acc)

ix <- match(tf_z_df$gene, names(tmp))
tf_z_df$exp_prom_cor <- tmp[ix]

# reverse ordering
ordered_acc <- ordered_acc[rev(rownames(ordered_acc)),]

plot_df <- reshape2::melt(as.matrix(ordered_acc))

colfunc.atac <- colorRampPalette(c(brewer.pal(9, 'RdPu' )[2:9]))

p <- plot_df %>% ggplot(aes(y=Var1, x=as.numeric(Var2), fill=value, color=value)) +
  rasterise(geom_tile(), dpi=800) +
  scale_color_gradientn(colors=colfunc.atac(256)) +
  scale_fill_gradientn(colors=colfunc.atac(256)) +
  theme(
    plot.margin = margin(0,0,0,0),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_text(face='italic', size=4),
    axis.ticks.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks.y = element_blank(),
    axis.title.y = element_blank()
  )


pdf(paste0(fig_dir, cur_group, '_tf_promoter_accessibility_heatmap.pdf'), width=5, height=10)
p / prop_tp / prop_ct + plot_layout(heights=c(15, 1, 1), guides='collect')
dev.off()


save(z_df, recon_df, ordered, smoothed, tf_z_df, motif_df, tf_cor_mat, ordered_acc, file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

```

Find TFs that regulate each other:

need to run "setup motif data" block above for this to work

```{r eval=FALSE}

# number of TFs in our seurat object:
length(unique(motif_df$motif_name[motif_df$motif_name %in% rownames(seurat_rna)]))

# number of TFs that are dynamically expressed:
length(unique(motif_df$motif_name[motif_df$motif_name %in% z_df$gene]))

# TF list from collaborators:
tfs <- list(
  'cholesterol' = c(
    'Srebf1','Srebf2','Ppara',
    'Ppard','Pparg','Rxr', 'Nr1h3','Nr1h2','Rxra','Rxrb','Rxrg','Xbp'
  ),
  'oligo' = c(
    'Sox10', 'Olig1','Zdp536','Olig2','Myrf',
    'Nkx2-2','Yy1','Znd24','Smad7','Nkx6-2','Id4',  'Id2','Tcf4'
  )
)
tfs <- unlist(tfs)
tfs <- tfs[tfs %in% rownames(seurat_rna)]
#tfs <- tfs[tfs %in% tf_z_df$gene]===

# violin plots for these TFs from collaborators:

for(cur_tf in tfs){
  print(cur_tf)
  p <- VlnPlot(seurat_rna, features = cur_tf, group.by='pseudotime_bins_10', pt.size=0) + NoLegend() +
    scale_fill_manual(values=alpha(plasma(10), 0.8)) +
    #geom_boxplot(width=.2, fill='white', outlier.shape=NA) +
    xlab('Pseudotime') +
    theme(
      axis.text.x=element_blank(),
      axis.ticks.x=element_blank(),
      axis.line.x=element_blank()
    )

  outfile <- paste0(fig_dir, "VlnPlots/", cur_group, '_', cur_tf,'_vln.pdf')
  pdf(outfile, width=6, height=3, useDingbats=FALSE)
  print(p)
  dev.off()
}


TopFeaturesInBins <- function(
  avg_df,
  start_bin, end_bin,
  feat_percentile = 0.9
){

  if(start_bin >= end_bin){
    return(c())
  }

  if(start_bin < 1){start_bin <- 1}
  if(end_bin > ncol(avg_df)){end_bin <- ncol(avg_df)}


  features <- unlist(lapply(start_bin:end_bin, function(i){
    rownames(avg_df)[avg_df[,i] >= quantile(avg_df[,i], feat_percentile)]
  }))
  unique(features)
}

# Not using this anymore
avg_expr <- AverageExpression(seurat_rna, slot='data', group.by = 'pseudotime_bins_50')$RNA
expressed_genes <- TopFeaturesInBins(avg_expr, 1, 50)

# average by group:
avg_acc <- AverageExpression(
  subset(seurat_atac_both, Cell.Type %in% c('OPC', 'ODC')),
  assay='peaks', slot='data', group.by = 'pseudotime_bins_50'
)$peaks
accessible_peaks <- TopFeaturesInBins(avg_acc, 1, 50, feat_percentile=0.90)
length(accessible_peaks)

subset(peakset, peak %in% accessible_peaks) %>% .$peakType %>% table
subset(peakset, peak %in% accessible_peaks & peakType == 'Promoter' & nearestGene == 'Mbp')
subset(peakset, peakType == 'Promoter' & nearestGene == 'Mbp')

# get the average chromvar for each bin, and
# avg_dev <- AverageExpression(seurat_atac, assay='chromvar', slot='data', group.by = 'pseudotime_bins_50')$chromvar
# accessible_peaks <- TopFeaturesInBins(avg_acc, 1, 50, feat_percentile=0.95)

# load trajectory data
load(file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

# load cluster marker genes:
# deg_file <- "/dfs7/swaruplab/smorabit/collab/AMRF/analysis/DEGs/data/cluster_markers.csv"
# degs <- read.csv(deg_file, stringsAsFactors=FALSE)
#
# opc_degs <- degs %>% subset(group == 'OPC')

# subset by motifs that are OPC marker genes:
#  tf_z_df[tf_z_df$gene %in% opc_degs$gene,]

# get Z_df for just the TFs:
tf_z_df <- subset(z_df, gene %in% chromvar_motifs)
tf_z_df$motif_id <- motif_df$motif_id[match(as.character(tf_z_df$gene), motif_df$motif_name_mouse)]
tfs <- as.character(tf_z_df$gene)
dim(tf_z_df)

# how many tfs are lowly expressed?



# exclude TFs that are lowly expressewd
# expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.80)
# tfs <- as.character(tf_z_df$gene)
# tfs <- tfs[tfs %in% expressed_genes_09]
# length(tfs)

# settings:
cur_tf <- 'Sox21'
similar_bin_window <- 2
text_size <- 3
cor_thresh <- 0.8 # correlation thresh for plotting
overwrite_plots <- FALSE

target_df <- data.frame()
for(cur_tf in tfs){
  print(cur_tf)

  cur_tf_id <- motif_df %>% subset(motif_name_mouse == cur_tf) %>% .$motif_id
  cur_bin <- tf_z_df %>% subset(gene == cur_tf) %>% .$bin

  if(length(cur_tf_id) > 1){
    cur_tf_id <- cur_tf_id[1]
  }

  # get sites for this motif:
  cur_motif_sites <- Motifs(seurat_atac)@data[,cur_tf_id]
  cur_motif_sites <- names(cur_motif_sites)[cur_motif_sites == 1]

  # which of these sites overlap a gene promoter?
  promoter_sites <- peakset[peakset$peak %in% cur_motif_sites & peakset$peakType == 'Promoter',]
  promoter_genes <- unique(promoter_sites$nearestGene)
  promoter_genes <- promoter_genes[promoter_genes %in% z_df$gene]

  # tfs that have promoter binding sites for this tf
  #subset(tf_z_df, gene %in% promoter_genes & gene %in% expressed_genes)

  # which of these sites overlap an enhancer?
  enhancer_links <- subset(link_df, Peak2 %in% cur_motif_sites & Peak2 %in% accessible_peaks)
  enhancer_genes <- unique(enhancer_links$Peak1_nearestGene)
  enhancer_genes <- enhancer_genes[enhancer_genes %in% z_df$gene]

  #subset(tf_z_df, gene %in% enhancer_genes & gene %in% expressed_genes)


  # genes that are expressed
  # pre_exp_genes <- TopFeaturesInBins(avg_expr, 1, cur_bin - (similar_bin_window) -1)
  # suc_exp_genes <- TopFeaturesInBins(avg_expr, cur_bin + (similar_bin_window + 1), ncol(avg_expr))
  # sim_exp_genes <- TopFeaturesInBins(avg_expr, cur_bin - similar_bin_window, cur_bin+similar_bin_window)
  # expressed_genes <- unique(c(pre_exp_genes, suc_exp_genes, sim_exp_genes))

  # doing this step might not be a good idea
  # promoter_genes <- promoter_genes[promoter_genes %in% expressed_genes]
  # enhancer_genes <- enhancer_genes[enhancer_genes %in% expressed_genes]

  # # which promoter genes are predecessors / successors ?
  # pre_pro_genes <- subset(z_df, gene %in% promoter_genes & bin < cur_bin - similar_bin_window) %>% .$gene %>% as.character
  # suc_pro_genes <- subset(z_df, gene %in% promoter_genes & bin > cur_bin + similar_bin_window) %>% .$gene %>% as.character
  # sim_pro_genes <- subset(z_df, gene %in% promoter_genes & bin <= cur_bin + similar_bin_window & bin >= cur_bin-similar_bin_window) %>% .$gene %>% as.character
  #
  # # which enhancer genes are predecessors / successors ?
  # pre_enh_genes <- subset(z_df, gene %in% enhancer_genes & bin < cur_bin - similar_bin_window) %>% .$gene %>% as.character
  # suc_enh_genes <- subset(z_df, gene %in% enhancer_genes & bin > cur_bin + similar_bin_window) %>% .$gene %>% as.character
  # sim_enh_genes <- subset(z_df, gene %in% enhancer_genes & bin <= cur_bin + similar_bin_window & bin >= cur_bin-similar_bin_window) %>% .$gene %>% as.character
  #
  # # combined
  # pre_genes <- unique(c(pre_pro_genes, pre_enh_genes))
  # suc_genes <- unique(c(suc_pro_genes, suc_enh_genes))
  # sim_genes <- unique(c(sim_pro_genes, sim_enh_genes))
  #
  # # all target genes
  # target_genes <- c(pre_genes, suc_genes, sim_genes)
  # test <- subset(tf_z_df, gene %in% target_genes)

  target_genes <- unique(c(promoter_genes, enhancer_genes))

  # Sox8 targets Olig1 & Olig2 promoters and Tcf7l2 enhancer
  cur_target_df <- data.frame(
    source = cur_tf,
    target = target_genes
  )

  #cur_target_df$group <- ifelse(cur_target_df$target %in% pre_genes, 'predecessor','other'  )
  #cur_target_df$group <- ifelse(cur_target_df$target %in% suc_genes, 'successor',cur_target_df$group  )
  #cur_target_df$group <- ifelse(cur_target_df$target %in% sim_genes, 'contemporary',cur_target_df$group  )

  cur_target_df$bs_group <- ifelse(
    cur_target_df$target %in% promoter_genes & cur_target_df$target %in% enhancer_genes, 'Both',
    ifelse(cur_target_df$target %in% promoter_genes, "Promoter",
    ifelse(cur_target_df$target %in% enhancer_genes, "Enhancer", NA
  )))

  cur_target_df$target_type <- ifelse(
    cur_target_df$target %in% tfs, 'TF', 'other'
  )

  # add correlation info
  cur_target_df$cor <- as.numeric(tf_cor_mat[cur_tf,as.character(cur_target_df$target)])

  # add Z coordinates of source and target
  ix <- match(cur_target_df$source, z_df$gene)
  cur_target_df$Z1_source <- z_df$Z1[ix]
  cur_target_df$Z2_source <- z_df$Z2[ix]
  ix <- match(cur_target_df$target, z_df$gene)
  cur_target_df$Z1_target <- z_df$Z1[ix]
  cur_target_df$Z2_target <- z_df$Z2[ix]

  # compute distances
  target_coords <- cur_target_df %>% dplyr::select(c(Z1_target, Z2_target))
  rownames(target_coords) <- cur_target_df$target; colnames(target_coords) <- c('Z1', 'Z2')
  source_coords <- cur_target_df[1,c('Z1_source', 'Z2_source')]; colnames(source_coords) <- c('Z1', 'Z2'); rownames(source_coords) <- cur_tf

  if(cur_tf %in% rownames(target_coords)){
    cur_coord <- which(rownames(target_coords) == cur_tf)
    coords <- rbind(target_coords[cur_coord,], target_coords[-cur_coord,])
  } else{
    coords <- rbind(source_coords, target_coords)
  }

  cur_distances <- as.matrix(dist(as.matrix(coords), method='euclidean'))[cur_tf,]
  ix <- match(cur_target_df$target, names(cur_distances))
  cur_target_df$dist <- as.numeric(cur_distances[ix])

  # update whole target df
  target_df <- rbind(target_df, cur_target_df)


  # plot
  plot_df <- z_df
  plot_df$bs_group <- ifelse(
    z_df$gene %in% promoter_genes & z_df$gene %in% enhancer_genes, 'Both',
    ifelse(z_df$gene %in% promoter_genes, "Promoter",
    ifelse(z_df$gene %in% enhancer_genes, "Enhancer", NA
  )))

  # plot_df$dev_cor <- as.numeric(dev_cor_mat[cur_tf,as.character(plot_df$gene)])
  plot_df$exp_cor <- as.numeric(tf_cor_mat[cur_tf,as.character(plot_df$gene)])


  shapes = c(24,22,21)

  # label certain genes of interest?
  plot_df$anno <- ifelse(plot_df$exp_cor >= cor_thresh & plot_df$gene %in% target_genes[target_genes %in% chromvar_motifs], as.character(plot_df$gene), NA)

  # add value to plot
  plot_df$value <- plot_df$exp_cor
  limits <- max(abs(min(plot_df$value)), max(plot_df$value))
  limits <- c(-1*limits, limits)

  # plot TF correlation on Z embedding
  outfile <- paste0(fig_dir, "TF_correlations/", cur_group, '_Z_', cur_tf,'_correlation.pdf')
  if(!file.exists(outfile) | overwrite_plots){

    p <- subset(plot_df, !is.na(bs_group)) %>%
      ggplot(aes(Z1, Z2, fill=value, shape=bs_group)) +
      ggrastr::rasterise(geom_point(inherit.aes=FALSE, data=subset(plot_df, is.na(bs_group)), aes(Z1,Z2), color='gray', fill='gray', alpha=0.25, size=0.5), dpi=400) +
      ggrastr::rasterise(geom_point(size=2, color=alpha('black', 0)), dpi=800) +
      geom_point(inherit.aes=FALSE, data=subset(plot_df, !is.na(bs_group) & !is.na(anno)), aes(Z1,Z2, fill=value, shape=bs_group), size=3, color='black') +
      scale_shape_manual(values=shapes) +
      geom_text_repel(data = dplyr::filter(plot_df, anno != ''), aes(label=anno), min.segment.length=0, fontface='italic', max.overlaps=Inf, size=text_size) +
      scale_fill_gradientn(
        colors=rev(brewer.pal(11, 'Spectral')),
        limit = limits,
        breaks = c(limits[1], 0, limits[2]),
        labels = c('-', 0, '+'),
        guide = guide_colorbar(barwidth=0.5, barheight=5, ticks=FALSE)
      ) +
    #  scale_color_manual(values=subset(plot_df, bs) %>% .$anno_outline) +
      labs(fill='',shape='') +
      ggtitle(paste0(cur_tf)) + theme(plot.title = element_text(hjust=0.5)) +
       coord_fixed(ratio = 1)

    pdf(outfile, width=7, height=5, useDingbats=FALSE)
    # print(p1  + umap_theme)
    print(p + umap_theme)
    dev.off()
  }

  # plot gene expression
  outfile <- paste0(fig_dir, "VlnPlots/", cur_group, '_', cur_tf,'_vln.pdf')
  if(!file.exists(outfile) | overwrite_plots){
    p <- VlnPlot(seurat_rna, features = cur_tf, group.by='pseudotime_bins_10', pt.size=0) + NoLegend() +
      scale_fill_manual(values=alpha(plasma(10), 0.8)) +
      #geom_boxplot(width=.2, fill='white', outlier.shape=NA) +
      xlab('Pseudotime') +
      theme(
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.line.x=element_blank()
      )


    pdf(outfile, width=6, height=3, useDingbats=FALSE)
    print(p)
    dev.off()
  }

  # plot coverage plot
  outfile <- paste0(fig_dir, "CoveragePlots/", cur_group, '_', cur_tf,'_covplot.pdf')
  if(!file.exists(outfile) | overwrite_plots){

    expr_plot <- ExpressionPlot(
      object = seurat_rna,
      features=cur_tf,
      group.by='pseudotime_bins_10',
      assay = "RNA"
    ) +  scale_fill_manual(values=plasma(10))


    # get the coordinates
    cur_region <- Annotation(seurat_atac) %>% subset(gene_name == cur_tf) %>% Extend(upstream=1000, downstream=1000)
    if(length(cur_region) > 0){

      # length of region
      #region_len <- max(end(cur_region)) - min(start(cur_region))
      cur_chr <- unique(as.character(seqnames(cur_region)))
      plot_region <- paste(cur_chr, min(start(cur_region)),max(end(cur_region)), sep='-')

      # coverage plot for snATAC cluster

      p1 <- CoveragePlot(
        object = seurat_atac,
        group.by='pseudotime_bins_10',
        region = plot_region,
        annotation = FALSE, peaks = FALSE, tile = FALSE, links = FALSE
      )
      p1 <- p1 + scale_fill_manual(values=plasma(10))
      p2 <- AnnotationPlot(seurat_atac, region=plot_region)

      p <- CombineTracks(
        plotlist=list(p1,p2),
        expression.plot = expr_plot,
        heights=c(10,1),
        widths=c(10,1)
      )

      pdf(outfile, width=6, height=10, useDingbats=FALSE)
      print(p)
      #print(p1 / p2 + plot_layout(heights=c(10,1)))
      dev.off()


      cur_pos <- subset(genebodyandpromoter.coords, symbol==cur_tf)
      chr <- as.character(seqnames(cur_pos))
      gen <- 'mm10'
      itrack <- IdeogramTrack(genome = gen, chromosome = chr)
      print(paste(cur_tf, 'chr:', as.character(seqnames(cur_pos)), ',', abs(start(cur_pos) - end(cur_pos)) + 2000))

      pdf(paste0(fig_dir, 'CoveragePlots/', cur_group, '_', cur_tf, '_ideogram.pdf'), width=8, height=2, useDingbats=FALSE)
      print(plotTracks(list(itrack), from=start(cur_pos)[1], to=end(cur_pos)[1], showId=FALSE))
      dev.off()

    }

  }

}



# write the output
write.csv(target_df, file=paste0(data_dir, cur_celltype, '_', cur_group, '_tf_target_df.csv') )

# re-load
target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_tf_target_df.csv'))

length(unique(target_df$source))

#####################################################################
# how many tfs?
#####################################################################

old_target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', 'Old_tf_target_df.csv'))
young_target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_',  'Young_tf_target_df.csv'))

length(unique(old_target_df$source))
length(unique(young_target_df$source))


```


Identify most likely tfs for each gene using XGBoost

```{r eval=FALSE}

library(xgboost)
library(tictoc)



target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_tf_target_df.csv') )


# list of target genes to run XGBoost on:
# gene_list <- tfs
gene_list <- unique(target_df$target)
#gene_list <- tf_z_df$gene

# initialize progress bar
pb <- utils::txtProgressBar(min = 0, max = length(gene_list), style = 3, width = 50, char = "=")
counter <- 1

# set up XGBoost model parameters
model_params <- list(
  objective = 'reg:squarederror',
  max_depth = 3,
  eta = 0.1,
  nthread=16,
  alpha=0.5
)
nfold=5

importance_df <- data.frame()
eval_df <- data.frame()

ts <- tic()
for(cur_target in gene_list){

  setTxtProgressBar(pb, counter)

  # build the model for one TF and one target gene
  cur_tfs <- target_df %>% subset(target == cur_target) %>% .$source %>% as.character %>% unique
  cur_tfs <- cur_tfs[cur_tfs != cur_target]

  if(length(cur_tfs) < 3){
    counter <- counter + 1
    next
  }

  dat = t(GetAssayData(seurat_rna, slot='data')[c(cur_target, cur_tfs),])

  # model matrix
  x_vars <- dat[,-1]
  y_var <- as.numeric(dat[,1])

  # run xgboost model
  # getting an error here on Foxa2 gene
  # oh it's cause it's all zeros hahaha

  if(all(y_var == 0)){
    print(paste0('skipping ', cur_target))
    next
  }
  xgb <- xgb.cv(
    params = model_params,
    data = x_vars,
    label = y_var,
    nrounds = 100,
    showsd = FALSE,
    nfold = nfold,
    callbacks = list(cb.cv.predict(save_models=TRUE)),
    verbose=FALSE
  )


  # get the CV evaluation info
  xgb_eval <- as.data.frame(xgb$evaluation_log)
  xgb_eval$variable <- cur_target

  # average the importance score from each fold
  importance <- Reduce('+', lapply(1:nfold, function(i){
    cur_imp <- xgb.importance(feature_names = colnames(x_vars), model = xgb$models[[i]])
    ix <- match(colnames(x_vars),  as.character(cur_imp$Feature))
    cur_imp <- as.matrix(cur_imp[ix,-1])
    cur_imp[is.na(cur_imp)] <- 0
    cur_imp
  })) / nfold
  importance <- as.data.frame(importance)

  # add tf and source info
  importance$source <- colnames(x_vars)
  importance$target <- cur_target

  # add pearson correlation of gene expression
  importance$exp_cor <- cor(as.matrix(x_vars), y_var)

  # re-order columns, and re-order rows by gain:
  importance <- importance %>% dplyr::select(c(source, target, Gain, Cover, Frequency, exp_cor))
  importance <- arrange(importance, -Gain)

  # append
  importance_df <- rbind(importance_df, importance)
  eval_df <- rbind(eval_df, xgb_eval)

  # update progress bar
  counter <- counter+1

}
te <- toc()

# how many hours did it take
(te$toc - te$tic) / 60 / 60

# close progress bar
close(pb)

subset(importance_df, target == 'Cnp') %>% head
subset(importance_df, target == 'Opalin') %>% head
subset(importance_df, target == 'Klk6') %>% head
subset(importance_df, target == 'Tcf4') %>% head
subset(importance_df, target == 'Zeb1') %>% head

write.csv(importance_df, file=paste0(data_dir, cur_celltype, '_', cur_group, '_xgboost_importance.csv') )

# reload xgboost results
importance_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_xgboost_importance.csv') )

#####################################################################
# how many tfs?
#####################################################################

old_target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', 'Old_tf_target_df.csv'))
young_target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_',  'Young_tf_target_df.csv'))

old_importance_df <-  read.csv(file=paste0(data_dir, cur_celltype, '_', 'Old_xgboost_importance.csv') )
young_importance_df <-  read.csv(file=paste0(data_dir, cur_celltype, '_', 'Young_xgboost_importance.csv') )

length(unique(old_target_df$source))
length(unique(young_target_df$source))

length(unique(old_importance_df$source))
length(unique(young_importance_df$source))

```


dijkstra pathfinding for TFs that activate expression

```{r eval=FALSE}

library(ggnetwork)
library(network)
library(sna)
library(igraph)
library(intergraph)

cur_group <- 'Young'

load(file=paste0(data_dir, cur_celltype, '_', cur_group, '_expression_trajectory_data.rda'))

importance_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_xgboost_importance.csv') )

target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_tf_target_df.csv') ) %>% dplyr::select(-X)

critical_nodes <- c('Sox10', 'Nkx2-2', 'Nkx6-2', 'Tcf4', 'Olig1', 'Olig2')


# tf_z_df <- subset(z_df, gene %in% target_df$target)


# exclude TFs that are lowly expressewd
# expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.90) # what I used before
#expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.80)

tfs <- as.character(tf_z_df$gene)
# tfs <- tfs[tfs %in% expressed_genes_09]

target_df <- subset(target_df, source %in% tfs)

full_tf_z_df <- tf_z_df
tf_z_df <- subset(full_tf_z_df, gene %in% tfs)

# add bins to the target_df
ix <- match(target_df$source, as.character(z_df$gene))
target_df$source_bin <- z_df$bin[ix]
ix <- match(target_df$target, as.character(z_df$gene))
target_df$target_bin <- z_df$bin[ix]
target_df$bin_dist <- abs(target_df$source_bin - target_df$target_bin)

# update weights based on binding sites:
bs_weights <- c(1, 0.75, 0.5); names(bs_weights) <- c('Both', 'Promoter', 'Enhancer')
ix <- match(target_df$bs_group, names(bs_weights))
target_df$bs_weight <- bs_weights[ix]


# add importance d
target_df$pair <- paste0(as.character(target_df$source), '_', as.character(target_df$target))
importance_df$pair <- paste0(as.character(importance_df$source), '_', as.character(importance_df$target))
target_df <- subset(target_df, pair %in% importance_df$pair)
ix <- match(target_df$pair, importance_df$pair)
target_df$Gain <- importance_df$Gain[ix]
target_df$exp_cor <- importance_df$exp_cor[ix]

# composite distance metric:
# target_df$weight <- log(1 + (target_df$dist / (target_df$cor^2)))
# target_df$weight <- ifelse(target_df$dist == 0, 0, target_df$weight)

# weights based on the Z-dist, correlation, and bs_weight
#target_df$weight <- sign(target_df$cor) * (target_df$dist / (target_df$cor^2)) * target_df$bs_weight

# weight basewd on Z-dist, correlation, bs weight, bin distance
#target_df$weight <- sign(target_df$cor) * ((target_df$dist + target_df$bin_dist) / (target_df$cor^2)) * target_df$bs_weight

# weight is based on the predicted importance and bin dist
# for pathfinding, a small weight is better!
target_df$weight <- (target_df$Gain * target_df$bs_weight * target_df$bin_dist ) / (target_df$cor)


# set up directed graph comprising only TFs
edge_df <- target_df %>% subset(target %in% tfs & weight > 0)
valid_tfs <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% valid_tfs) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))
g1 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)

subset(target_df, source == 'Bach2' & target %in% tfs & weight)

#set up directed graph with TFs + all target genes:
edge_df <- target_df; genes.keep <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% genes.keep) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))
g2 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)


################################################################################
# TF-TF network
################################################################################

igraph::degree(g1,  v = V(g1)[V(g1)$name %in% tfs], mode='out')

lay <- as.matrix(cbind(V(g1)$Z1, V(g1)$Z2))
rownames(lay) <-  V(g1)$name

colr <- plasma(100)
ix <- round(scales::rescale(V(g1)$rank, to = c(1, 100)))
V(g1)$color <- colr[ix]

selected_genes <- c(critical_nodes)
selected_genes <-
V(g1)$label <- ifelse(V(g1)$name %in% selected_genes, V(g1)$name, '')


pdf(paste0(fig_dir, cur_group, '_tf_net_full.pdf'), width=10, height=10, useDingbats=F)

plot(
  g1,
  layout=lay,
  vertex.size=10,
  #edge.color = adjustcolor('grey', alpha=0.5),
  edge.color=unlist(lapply(E(g1)$Gain, function(x){adjustcolor('grey', alpha.f=5*x)})),
  edge.arrow.size=0.25,
  vertex.color=adjustcolor(V(g1)$color, alpha.f=1),
  vertex.frame.color=adjustcolor(V(g1)$color, alpha.f=1),
  vertex.alpha=0.1,
  vertex.label=V(g1)$name,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.color = 'black',
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g1)$Z1),
  ylim = range(V(g1)$Z2)
)

dev.off()




# end nodes as the last 10 by rank

# for young (did I sort them opposite of each other????)
# end_nodes <- tf_z_df %>% top_n(10, wt=-rank) %>% .$gene %>% as.character
# start_nodes <- tf_z_df %>% subset(bin > 45) %>% .$gene %>% as.character
# critical_nodes <- c('Sox10', 'Nkx2-2', 'Nkx6-2', 'Tcf4', 'Olig1', 'Olig2')

# to select these nodes, should I change the start / end to all TFs in the first or last bins?

start_nodes <- tf_z_df %>% subset(gene %in% names(V(g1))) %>%
  top_n(50, wt=-rank) %>% .$gene %>% as.character
end_nodes <- tf_z_df %>% subset(gene %in% names(V(g1))) %>%
  subset(bin > 45) %>% .$gene %>% as.character
critical_nodes <- c('Sox10', 'Nkx2-2', 'Nkx6-2', 'Tcf4', 'Olig1', 'Olig2')

all(critical_nodes %in% names(V(g1)))
all(start_nodes %in% names(V(g1)))
all(end_nodes %in% names(V(g1)))


vpath_list <- list()
epath_list <- c()

# paths between critical node and end nodes
for(cur_node in critical_nodes){
  print(cur_node)
  for(cur_end in end_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}


# paths between start node and end nodes
for(cur_node in start_nodes){
  print(cur_node)
  for(cur_end in end_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}

# paths between start node and critical nodes
for(cur_node in start_nodes){
  print(cur_node)
  for(cur_end in critical_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}



# get all the vertices:
vertices <- unique(unlist(lapply(vpath_list, function(x){x$name})))
vertices[!(vertices %in% start_nodes | vertices %in% end_nodes | vertices %in% critical_nodes)]

# get all the edges: (edges are stored as numeric edge ids)
edges <- unlist(epath_list)

# subset vertices
print(length(E(g1)))

# subset edges:
sub_g1 <- subgraph.edges(g1, edges)
vertices <- V(sub_g1)$name
print(length(E(sub_g1)))
print(length(V(sub_g1)$name))
vertices[!(vertices %in% V(sub_g1)$name)]

lay <- as.matrix(cbind(V(sub_g1)$Z1, V(sub_g1)$Z2))
rownames(lay) <-  V(sub_g1)$name
lay2 <- as.matrix(cbind(V(g2)$Z1, V(g2)$Z2))
rownames(lay2) <-  V(g2)$name


# color the graph bas
colfunc <- colorRampPalette(rev(brewer.pal(11, 'Spectral' )))
colfunc <- plasma
colr <- colfunc(256)
range1.100 <- function(x){1 + 255*(x-min(x))/(max(x)-min(x))}
V(sub_g1)$color <- colr[range1.100(V(sub_g1)$rank)]
V(g2)$color <- colr[range1.100(V(g2)$rank)]


# label selected:
selected_genes <- c(critical_nodes, 'Bach2', 'Tcf12', 'Zeb1', 'Rora', 'Srebf2', 'Stat3')
selected_genes <- V(sub_g1)$name
V(sub_g1)$label <- ifelse(V(sub_g1)$name %in% selected_genes, V(sub_g1)$name, '')
V(sub_g1)$size <- ifelse(V(sub_g1)$name %in% selected_genes, 1, 0.5)
V(sub_g1)$framecolor <- ifelse(V(sub_g1)$name %in% selected_genes, 'black', V(sub_g1)$color)

# edge_df <- data.frame(
#   edge = as.character(E(sub_g1)),
#   cor = E(sub_g1)$cor
# )


pdf(paste0(fig_dir, cur_group, '_test_igraph_xgb.pdf'), width=12, height=12, useDingbats=F)

plot(
  subgraph.edges(g2, c(), delete.vertices=FALSE),
  layout=lay2,
  vertex.size=5,
  #edge.width=0,
  vertex.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.frame.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.alpha=0.1,
  vertex.label='',
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2)
)


plot(
  sub_g1,
  layout=lay,
  #edge.color='black',
  edge.color=unlist(lapply(E(sub_g1)$cor, function(x){adjustcolor('black', alpha.f=x)})),
  vertex.size=20*V(sub_g1)$size,

  # edge.curved=0,
  # edge.width=0.5,
  vertex.color=V(sub_g1)$color,
  vertex.label=V(sub_g1)$label,
  # vertex.label.dist=1.1,
  # vertex.label.degree=-pi/4,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.color = 'black',
  vertex.label.cex=0.5,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2),
  add=TRUE,
  edge.arrow.size=0.25,
  vertex.frame.color=V(sub_g1)$color
  # vertex.frame.color=V(sub_g1)$framecolor
  # margin=0
)


dev.off()


################################################################################
# Make a graph with the top n outgoing connections for each TF in the critical path
################################################################################

sub_g1 <- subgraph.edges(g1, edges)
vertices <- V(sub_g1)$name
print(length(E(sub_g1)))
print(length(V(sub_g1)$name))
vertices[!(vertices %in% V(sub_g1)$name)]


top_connections <- 5

# set up directed graph comprising only TFs
edge_df <- target_df %>% subset(target %in% tfs & weight > 0) %>%
  group_by(source) %>% slice_min(order_by=weight, n=top_connections)
valid_tfs <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% valid_tfs) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))

g3 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)

# merge with the other graph
g_merge <- igraph::union(g3, sub_g1)

attrs <- rbind(as_data_frame(g3, "vertices"), as_data_frame(sub_g1, "vertices")[,1:5]) %>% unique()
el <- rbind(as_data_frame(g3), as_data_frame(sub_g1))

g_merge <- graph_from_data_frame(
  el, directed=TRUE, vertices=attrs
)

lay <- as.matrix(cbind(V(g_merge)$Z1, V(g_merge)$Z2))
rownames(lay) <-  V(g_merge)$name

# color the graph based on trajectory ranking
V(g_merge)$color <- colr[range1.100(V(g_merge)$rank)]


# label selected:
selected_genes <- c(critical_nodes, 'Bach2', 'Tcf12', 'Zeb1', 'Rora', 'Srebf2', 'Stat3')
#selected_genes <- V(g_merge)$name
V(g_merge)$label <- ifelse(V(g_merge)$name %in% selected_genes, V(g_merge)$name, '')
V(g_merge)$size <- ifelse(V(g_merge)$name %in% selected_genes, 1, 0.5)
V(g_merge)$framecolor <- ifelse(V(g_merge)$name %in% selected_genes, 'black', V(g_merge)$color)


pdf(paste0(fig_dir, cur_group, '_test_igraph_xgb_top.pdf'), width=12, height=12, useDingbats=F)

plot(
  subgraph.edges(g2, c(), delete.vertices=FALSE),
  layout=lay2,
  vertex.size=5,
  vertex.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.frame.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.alpha=0.1,
  vertex.label='',
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  edge.arrow.size=0.25,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2)
)


plot(
  g_merge,
  layout=lay,
  #edge.color='black',
  edge.color=unlist(lapply(E(g_merge)$cor, function(x){adjustcolor('black', alpha.f=x)})),
  vertex.size=20*V(g_merge)$size,

  # edge.curved=0,
  # edge.width=0.5,
  vertex.color=V(g_merge)$color,
  vertex.label=V(g_merge)$label,
  # vertex.label.dist=1.1,
  # vertex.label.degree=-pi/4,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.color = 'black',
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2),
  add=TRUE,
  edge.arrow.size=0.25,
  vertex.frame.color=V(g_merge)$framecolor
  # margin=0
)


dev.off()


subset(target_df, source == 'Bach2' & target %in% tfs) %>% arrange(weight) %>% head(15)
subset(target_df, target == 'Bach2' & weight > 0) %>% arrange(weight)



subset(target_df, source == 'Stat3' & target %in% tfs & cor < 0) %>% arrange(-Gain) %>% head(15)


```


Plot network stats

```{r eval=FALSE}


# plot TFs ranked by in degree
indeg <- igraph::degree(g1,  v = V(g1)[V(g1)$name %in% tfs], mode='in')
indeg <- igraph::degree(sub_g1,  v = V(sub_g1)[V(sub_g1)$name %in% tfs], mode='in')
plot_df <- data.frame(
  tf = names(indeg),
  degree = as.numeric(indeg)
)

p <- ggplot(plot_df, aes(x=reorder(tf, degree), y=degree, fill=degree )) +
  geom_bar(stat='identity') +
  geom_text(aes(label=tf),  color="black", size=2, hjust='inward') +
  scale_y_continuous(labels=scales::comma, limits=c(0,NA), expand=c(0,0)) +
  scale_fill_gradientn(colors=viridis(256)) +
  coord_flip() + NoLegend() + ylab('TF-TF Network in degree') + xlab('') +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.grid.major.x=element_line(color='lightgrey', size=0.25),
    panel.grid.minor=element_blank(),
    axis.ticks.y=element_blank(),
    axis.title.x=element_blank(),
    axis.line.y=element_blank(),
    axis.text.y = element_blank()
  ) + ggtitle("Number of incoming edges (in degree)")

pdf(paste0(fig_dir, cur_group, '_tf-network_indegree_sub.pdf'), width=5, height=7)
p
dev.off()

# plot TFs ranked by in degree
outdeg <- igraph::degree(g1,  v = V(g1)[V(g1)$name %in% tfs], mode='out')
plot_df <- data.frame(
  tf = names(outdeg),
  degree = as.numeric(outdeg)
)

p <- ggplot(plot_df, aes(x=reorder(tf, degree), y=degree, fill=degree )) +
  geom_bar(stat='identity') +
  geom_text(aes(label=tf),  color="black", size=2, hjust='inward') +
  scale_y_continuous(labels=scales::comma, limits=c(0,NA), expand=c(0,0)) +
  scale_fill_gradientn(colors=viridis(256)) +
  coord_flip() + NoLegend() + ylab('TF-TF Network in degree') + xlab('') +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.grid.major.x=element_line(color='lightgrey', size=0.25),
    panel.grid.minor=element_blank(),
    axis.ticks.y=element_blank(),
    axis.title.x=element_blank(),
    axis.line.y=element_blank(),
    axis.text.y = element_blank()
  ) + ggtitle("Number of outgoing edges (out degree)")

pdf(paste0(fig_dir, cur_group, '_tf-network_outdegree.pdf'), width=5, height=7)
p
dev.off()


# plot TFs ranked by in degree
outdeg <- igraph::degree(g2,  v = V(g2)[V(g2)$name %in% tfs], mode='out')
plot_df <- data.frame(
  tf = names(outdeg),
  degree = as.numeric(outdeg)
)

p <- ggplot(plot_df, aes(x=reorder(tf, degree), y=degree, fill=degree )) +
  geom_bar(stat='identity') +
  geom_text(aes(label=tf),  color="black", size=2, hjust='inward') +
  scale_y_continuous(labels=scales::comma, limits=c(0,NA), expand=c(0,0)) +
  scale_fill_gradientn(colors=viridis(256)) +
  coord_flip() + NoLegend() + ylab('TF-TF Network in degree') + xlab('') +
  theme(
    plot.title = element_text(hjust = 0.5),
    panel.grid.major.x=element_line(color='lightgrey', size=0.25),
    panel.grid.minor=element_blank(),
    axis.ticks.y=element_blank(),
    axis.title.x=element_blank(),
    axis.line.y=element_blank(),
    axis.text.y = element_blank()
  ) + ggtitle("Number of outgoing edges (out degree)")

pdf(paste0(fig_dir, 'tf-network_outdegree_full.pdf'), width=5, height=7)
p
dev.off()

################################################################################
# TF-TF network
################################################################################

lay <- as.matrix(cbind(V(g2)$Z1, V(g2)$Z2))
rownames(lay) <-  V(g2)$name

V(g2)$color <- colr[range1.100(V(g2)$rank)]

selected_genes <- c(critical_nodes)
selected_genes <-
V(g2)$label <- ifelse(V(g2)$name %in% tfs, V(g2)$name, '')
V(g2)$size <- ifelse(V(g2)$name %in% tfs, 1, 0.5)

V(g2)$color <- ifelse(V(g2)$name %in% tfs, V(g2)$color, adjustcolor(V(g2)$color, alpha.f=0.5))

pdf(paste0(fig_dir, cur_group, '_tf_net_full_targets.pdf'), width=10, height=10, useDingbats=F)

plot(
  g2,
  layout=lay,
  vertex.size=10*V(g2)$size,
  edge.color = adjustcolor('grey', alpha=0.1),
  edge.arrow.size=0.1,
  vertex.color=V(g2)$color,
  vertex.frame.color=V(g2)$color,
  vertex.alpha=0.1,
  vertex.label=V(g2)$label,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.color = 'black',
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2)
)

dev.off()


```





dijkstra pathfinding for TFs that REPRESS expression

```{r eval=FALSE}

library(ggnetwork)
library(network)
library(sna)
library(igraph)
library(intergraph)


importance_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_xgboost_importance.csv') )

target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_tf_target_df.csv') )
target_df <- dplyr::select(target_df, -X)

# exclude TFs that are lowly expressewd
# expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.90)
#expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.80)
tfs <- as.character(tf_z_df$gene)
#tfs <- tfs[tfs %in% expressed_genes_09]

target_df <- subset(target_df, source %in% tfs)

full_tf_z_df <- tf_z_df
tf_z_df <- subset(full_tf_z_df, gene %in% tfs)

# add bins to the target_df
ix <- match(target_df$source, as.character(z_df$gene))
target_df$source_bin <- z_df$bin[ix]
ix <- match(target_df$target, as.character(z_df$gene))
target_df$target_bin <- z_df$bin[ix]
target_df$bin_dist <- abs(target_df$source_bin - target_df$target_bin)

# update weights based on binding sites:
bs_weights <- c(1, 0.75, 0.5); names(bs_weights) <- c('Both', 'Promoter', 'Enhancer')
ix <- match(target_df$bs_group, names(bs_weights))
target_df$bs_weight <- bs_weights[ix]


# add importance d
target_df$pair <- paste0(as.character(target_df$source), '_', as.character(target_df$target))
importance_df$pair <- paste0(as.character(importance_df$source), '_', as.character(importance_df$target))
target_df <- subset(target_df, pair %in% importance_df$pair)
ix <- match(target_df$pair, importance_df$pair)
target_df$Gain <- importance_df$Gain[ix]
target_df$exp_cor <- importance_df$exp_cor[ix]

# composite distance metric:
# target_df$weight <- log(1 + (target_df$dist / (target_df$cor^2)))
# target_df$weight <- ifelse(target_df$dist == 0, 0, target_df$weight)

# weights based on the Z-dist, correlation, and bs_weight
#target_df$weight <- sign(target_df$cor) * (target_df$dist / (target_df$cor^2)) * target_df$bs_weight

# weight basewd on Z-dist, correlation, bs weight, bin distance
#target_df$weight <- sign(target_df$cor) * ((target_df$dist + target_df$bin_dist) / (target_df$cor^2)) * target_df$bs_weight

# weight is based on the predicted importance and bin dist
target_df$weight <- (target_df$Gain * target_df$bs_weight * target_df$bin_dist ) / (target_df$cor)

# multiply by -1 so I can look for repressors:
target_df$weight <- target_df$weight * -1


# set up directed graph comprising only TFs
edge_df <- target_df %>% subset(target %in% tfs & weight > 0)
vertices <- union(unique(edge_df$source), unique(edge_df$target))
vertex_df <- z_df %>% subset(gene %in% vertices) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))
g1 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)

#set up directed graph with TFs + all target genes:
edge_df <- target_df ; genes.keep <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% genes.keep) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))
g2 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)


################################################################################
# TF-TF network
################################################################################

igraph::degree(g1,  v = V(g1)[V(g1)$name %in% tfs], mode='out')

lay <- as.matrix(cbind(V(g1)$Z1, V(g1)$Z2))
rownames(lay) <-  V(g1)$name

V(g1)$color <- colr[range1.100(V(g1)$rank)]

selected_genes <- c(critical_nodes)
selected_genes <-
V(g1)$label <- ifelse(V(g1)$name %in% selected_genes, V(g1)$name, '')


pdf(paste0(fig_dir, cur_group, '_tf_net_repressive_full.pdf'), width=10, height=10, useDingbats=F)

plot(
  g1,
  layout=lay,
  vertex.size=10,
  #edge.color = adjustcolor('grey', alpha=0.5),
  edge.color=unlist(lapply(E(g1)$Gain, function(x){adjustcolor('grey', alpha.f=5*x)})),
  edge.arrow.size=0.25,
  vertex.color=adjustcolor(V(g1)$color, alpha.f=1),
  vertex.frame.color=adjustcolor(V(g1)$color, alpha.f=1),
  vertex.alpha=0.1,
  vertex.label=V(g1)$name,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.color = 'black',
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g1)$Z1),
  ylim = range(V(g1)$Z2)
)

dev.off()




# end nodes as the last 10 by rank

# for young (did I sort them opposite of each other????)
# end_nodes <- tf_z_df %>% top_n(10, wt=-rank) %>% .$gene %>% as.character
# start_nodes <- tf_z_df %>% subset(bin > 45) %>% .$gene %>% as.character
# critical_nodes <- c('Sox10', 'Nkx2-2', 'Nkx6-2', 'Tcf4', 'Olig1', 'Olig2')


start_nodes <- tf_z_df %>% subset(gene %in% names(V(g1))) %>%
  top_n(50, wt=-rank) %>% .$gene %>% as.character
end_nodes <- tf_z_df %>% subset(gene %in% names(V(g1))) %>%
  subset(bin > 45) %>% .$gene %>% as.character
critical_nodes <- c('Sox10', 'Nkx2-2', 'Nkx6-2', 'Tcf4', 'Olig1', 'Olig2')

all(critical_nodes %in% names(V(g1)))
all(start_nodes %in% names(V(g1)))
all(end_nodes %in% names(V(g1)))

vpath_list <- list()
epath_list <- c()

# paths between  end nodes and critical nodes
for(cur_node in end_nodes){
  print(cur_node)
  for(cur_end in critical_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}


# paths between end nodes and start nodes
for(cur_node in end_nodes){
  print(cur_node)
  for(cur_end in start_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}

# paths between critical nodes and start nodes
for(cur_node in critical_nodes){
  print(cur_node)
  for(cur_end in start_nodes){
    cur_paths <- shortest_paths(
      g1,
      from = cur_node,
      to = cur_end,
      mode = c("out"),
      weights = NULL,
      output = 'both'
    )
    vpath_list <- c(vpath_list, cur_paths$vpath)
    epath_list <- c(epath_list, cur_paths$epath)
  }
}



# get all the vertices:
vertices <- unique(unlist(lapply(vpath_list, function(x){x$name})))
vertices[!(vertices %in% start_nodes | vertices %in% end_nodes | vertices %in% critical_nodes)]

# get all the edges: (edges are stored as numeric edge ids)
edges <- unlist(epath_list)

# subset vertices
print(length(E(g1)))

# subset edges:
sub_g1 <- subgraph.edges(g1, edges)
vertices <- V(sub_g1)$name
print(length(E(sub_g1)))
print(length(V(sub_g1)$name))
vertices[!(vertices %in% V(sub_g1)$name)]

lay <- as.matrix(cbind(V(sub_g1)$Z1, V(sub_g1)$Z2))
rownames(lay) <-  V(sub_g1)$name
lay2 <- as.matrix(cbind(V(g2)$Z1, V(g2)$Z2))
rownames(lay2) <-  V(g2)$name


# color the graph bas
colfunc <- colorRampPalette(rev(brewer.pal(11, 'Spectral' )))
colfunc <- plasma
colr <- colfunc(256)
range1.100 <- function(x){1 + 255*(x-min(x))/(max(x)-min(x))}
V(sub_g1)$color <- colr[range1.100(V(sub_g1)$rank)]
V(g2)$color <- colr[range1.100(V(g2)$rank)]


# label selected:
selected_genes <- c(critical_nodes, 'Bach2', 'Tcf12', 'Zeb1', 'Rora', 'Srebf2', 'Stat3')
selected_genes <- V(sub_g1)$name
V(sub_g1)$label <- ifelse(V(sub_g1)$name %in% selected_genes, V(sub_g1)$name, '')
V(sub_g1)$size <- ifelse(V(sub_g1)$name %in% selected_genes, 1, 0.5)
V(sub_g1)$framecolor <- ifelse(V(sub_g1)$name %in% selected_genes, 'black', V(sub_g1)$color)

# edge_df <- data.frame(
#   edge = as.character(E(sub_g1)),
#   cor = E(sub_g1)$cor
# )


pdf(paste0(fig_dir, cur_group, '_test_igraph_xgb_repressive.pdf'), width=12, height=12, useDingbats=F)

plot(
  subgraph.edges(g2, c(), delete.vertices=FALSE),
  layout=lay2,
  vertex.size=5,
  #edge.width=0,
  vertex.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.frame.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.alpha=0.1,
  vertex.label='',
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2)
)


plot(
  sub_g1,
  layout=lay,
  #edge.color='black',
  edge.color=unlist(lapply(E(sub_g1)$cor * -1, function(x){adjustcolor('black', alpha.f=x)})),
  vertex.size=20*V(sub_g1)$size,

  # edge.curved=0,
  # edge.width=0.5,
  vertex.color=V(sub_g1)$color,
  vertex.label=V(sub_g1)$label,
  # vertex.label.dist=1.1,
  # vertex.label.degree=-pi/4,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.color = 'black',
  vertex.label.cex=0.5,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2),
  add=TRUE,
  edge.arrow.size=0.25,
  vertex.frame.color=V(sub_g1)$framecolor
  # margin=0
)


dev.off()


################################################################################
# Make a graph with the top n outgoing connections for each TF in the critical path
################################################################################

sub_g1 <- subgraph.edges(g1, edges)
vertices <- V(sub_g1)$name
print(length(E(sub_g1)))
print(length(V(sub_g1)$name))
vertices[!(vertices %in% V(sub_g1)$name)]


top_connections <- 5

# set up directed graph comprising only TFs
edge_df <- target_df %>% subset(target %in% tfs & weight > 0) %>%
  group_by(source) %>% slice_min(n=top_connections, order_by=weight)
valid_tfs <- unique(c(edge_df$source, edge_df$target))
vertex_df <- z_df %>% subset(gene %in% valid_tfs) %>%
  dplyr::select(c(gene, Z1, Z2, rank, bin))

g3 <- igraph::graph_from_data_frame(
  edge_df,
  directed=TRUE,
  vertices=vertex_df
)

# merge with the other graph
g_merge <- igraph::union(g3, sub_g1)

attrs <- rbind(as_data_frame(g3, "vertices"), as_data_frame(sub_g1, "vertices")[,1:5]) %>% unique()
el <- rbind(as_data_frame(g3), as_data_frame(sub_g1))

g_merge <- graph_from_data_frame(
  el, directed=TRUE, vertices=attrs
)

lay <- as.matrix(cbind(V(g_merge)$Z1, V(g_merge)$Z2))
rownames(lay) <-  V(g_merge)$name

# color the graph based on trajectory ranking
V(g_merge)$color <- colr[range1.100(V(g_merge)$rank)]


# label selected:
selected_genes <- c(critical_nodes, 'Bach2', 'Tcf12', 'Zeb1', 'Rora', 'Srebf2', 'Stat3')
#selected_genes <- V(g_merge)$name
V(g_merge)$label <- ifelse(V(g_merge)$name %in% selected_genes, V(g_merge)$name, '')
V(g_merge)$size <- ifelse(V(g_merge)$name %in% selected_genes, 1, 0.5)
V(g_merge)$framecolor <- ifelse(V(g_merge)$name %in% selected_genes, 'black', V(g_merge)$color)


pdf(paste0(fig_dir, cur_group, '_test_igraph_xgb_repressive_top.pdf'), width=12, height=12, useDingbats=F)

plot(
  subgraph.edges(g2, c(), delete.vertices=FALSE),
  layout=lay2,
  vertex.size=5,
  vertex.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.frame.color=adjustcolor(V(g2)$color, alpha.f=0.2),
  vertex.alpha=0.1,
  vertex.label='',
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.cex=1,
  rescale=F,
  edge.arrow.size=0.25,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2)
)


plot(
  g_merge,
  layout=lay,
  #edge.color='black',
  edge.color=unlist(lapply(E(g_merge)$cor * -0.25, function(x){adjustcolor('black', alpha.f=x)})),
  vertex.size=20*V(g_merge)$size,

  # edge.curved=0,
  # edge.width=0.5,
  vertex.color=V(g_merge)$color,
  vertex.label=V(g_merge)$label,
  # vertex.label.dist=1.1,
  # vertex.label.degree=-pi/4,
  vertex.label.family='Helvetica', #vertex.label.font=vertex_df$font,
  vertex.label.font = 3,
  vertex.label.color = 'black',
  vertex.label.cex=1,
  rescale=F,
  xlim = range(V(g2)$Z1),
  ylim = range(V(g2)$Z2),
  add=TRUE,
  edge.arrow.size=0.25,
  vertex.frame.color=V(g_merge)$framecolor
  # margin=0
)


dev.off()


subset(target_df, source == 'Bach2' & target %in% tfs) %>% arrange(weight) %>% head(15)
subset(target_df, target == 'Bach2' & weight > 0) %>% arrange(weight)



subset(target_df, source == 'Stat3' & target %in% tfs & cor < 0) %>% arrange(-Gain) %>% head(15)


```



save target df for collaborators

```{r eval=FALSE}


importance_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_xgboost_importance.csv') )

target_df <- read.csv(file=paste0(data_dir, cur_celltype, '_', cur_group, '_tf_target_df.csv') )
target_df <- dplyr::select(target_df, -X)

# exclude TFs that are lowly expressewd
# expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.90)
#expressed_genes_09 <- TopFeaturesInBins(avg_expr, 1, 50, feat_percentile=0.80)
tfs <- as.character(tf_z_df$gene)
#tfs <- tfs[tfs %in% expressed_genes_09]

target_df <- subset(target_df, source %in% tfs)
full_tf_z_df <- tf_z_df
tf_z_df <- subset(full_tf_z_df, gene %in% tfs)

# add bins to the target_df
ix <- match(target_df$source, as.character(z_df$gene))
target_df$source_bin <- z_df$bin[ix]
ix <- match(target_df$target, as.character(z_df$gene))
target_df$target_bin <- z_df$bin[ix]
target_df$bin_dist <- abs(target_df$source_bin - target_df$target_bin)

# update weights based on binding sites:
bs_weights <- c(1, 0.75, 0.5); names(bs_weights) <- c('Both', 'Promoter', 'Enhancer')
ix <- match(target_df$bs_group, names(bs_weights))
target_df$bs_weight <- bs_weights[ix]


# add importance d
target_df$pair <- paste0(as.character(target_df$source), '_', as.character(target_df$target))
importance_df$pair <- paste0(as.character(importance_df$source), '_', as.character(importance_df$target))
target_df <- subset(target_df, pair %in% importance_df$pair)
ix <- match(target_df$pair, importance_df$pair)
target_df$Gain <- importance_df$Gain[ix]
target_df$exp_cor <- importance_df$exp_cor[ix]

# composite distance metric:
# target_df$weight <- log(1 + (target_df$dist / (target_df$cor^2)))
# target_df$weight <- ifelse(target_df$dist == 0, 0, target_df$weight)

# weights based on the Z-dist, correlation, and bs_weight
#target_df$weight <- sign(target_df$cor) * (target_df$dist / (target_df$cor^2)) * target_df$bs_weight

# weight basewd on Z-dist, correlation, bs weight, bin distance
#target_df$weight <- sign(target_df$cor) * ((target_df$dist + target_df$bin_dist) / (target_df$cor^2)) * target_df$bs_weight

# weight is based on the predicted importance and bin dist
target_df$weight <- (target_df$Gain * target_df$bs_weight * target_df$bin_dist ) / (target_df$cor)



# select columns to output:

columns <- c('source', 'target', 'bs_group', 'cor', 'dist', 'Gain')
df <- target_df[,columns]

df <- dplyr::rename(df, c(importance=Gain))

write.csv(df, quote=FALSE, row.names=FALSE, file=paste0(cur_celltype, '_', cur_group, '_TF_connections.csv'))

# count number of outgoing for each TFs
n_out <- df %>% subset(target %in% tfs) %>% dplyr::count(source)

# count number of outgoing for each TFs
n_in <- df %>% subset(target %in% tfs) %>% dplyr::count(target)


ix <- match(n_in$target, n_out$source)

n_out$n_in <- n_in$n[ix]


ifelse(1:nrow(n_out) == n_out$target)

```






















DANGER ZONE


Old below, testing lasso / ridge regression



To refine the target genes, we can run code very similar to cell oracle page 28 of their paper

* should try averaged expression over pseudotime?
* should try just gene expression? Stratified by pseudotime bin?
* Note: lasso and ridge regression give coefficients but not p values

```{r eval=FALSE}

library(glmnet)

cur_tf <- 'Olig1'
cur_target <- 'Atp5l'

# build the model for one TF and one target gene
cur_tfs <- target_df %>% subset(target == cur_target) %>% .$source %>% as.character %>% unique
cur_tfs <- cur_tfs[cur_tfs != cur_target]

dat = t(GetAssayData(seurat_rna, slot='data')[c(cur_target, cur_tfs),])


# linear regression
model <- lm(get(cur_target) ~ get(cur_tf), data=dat)

# model matrix
# x_vars <- model.matrix(Atp5l~., dat)[,-1]
x_vars <- dat[,-1]
y_var <- dat[,1]

# 10 fold cross validation to determine the best value for lambda
# running lasso on an example dataset:
alpha <- 0.5 # alpha = 0.5 means elastic net regression. alpha=1 is lasso, alpha=0 is ridge (aka no penalty)
cv_output <- cv.glmnet(
  x_vars,
  y_var,
  alpha=alpha,
  nlambda=100,
  nfolds=10,
  type.measure='mse'
)

# get the best lambda value:
best_lam <- cv_output$lambda.min
best_lam

lasso_best <- glmnet(x_vars, y_var, alpha = alpha, lambda = best_lam)
b <- coef(lasso_best)
coef(lasso_best)


```








Plot single trajectory plot for one TF

```{r eval=FALSE}

subset(tf_z_df, exp_motif_cor >= 0.25)

cur_tf <- 'Olig1'
cur_tf <- 'Tcf4'
cur_tf <- 'Olig2'
cur_tf <- 'Sox10'
cur_tf <- 'Nkx6-2'

print(subset(tf_z_df, gene== cur_tf))

# get the expression, and motif deviation info:

cur_exp <- as.numeric(ordered[cur_tf,])
cur_dev <- as.numeric(ordered_dev[cur_tf,])
cur_prom <- as.numeric(ordered_acc[cur_tf,])

plot_df <- data.frame(
  bin = levels(prop_df$bin),
  exp = cur_exp,
  motif = cur_dev,
  promoter = cur_prom
)
plot_df$bin <- factor(plot_df$bin, levels=levels(prop_df$bin))


plot_df <- reshape2::melt(plot_df)
plot_df$bin <- as.numeric(plot_df$bin)

p <- ggplot(plot_df, aes(x=bin, y=value, color=variable, fill=variable)) +
  geom_smooth(se=FALSE) +
  theme(
    axis.ticks.x = element_blank(),
    axis.text.x = element_blank(),
    axis.line.x = element_blank(),
    axis.title.x = element_blank(),
    plot.title = element_text(hjust = 0.5)
  )  + ylab('Scaled Value') + ggtitle(cur_tf)

pdf(paste0(fig_dir, "TF_trajectories/", cur_group, '_', cur_tf,'_trajectory.pdf'), width=8, height=4, useDingbats=FALSE)
p / prop_tp / prop_ct + plot_layout(heights=c(10, 1, 1), guides='collect')
dev.off()

```














Test footprinting:

```{r eval=FALSE}

library(BSgenome.Mmusculus.UCSC.mm10)


temp <- subset(seurat_subset, tech == 'atac')
seurat_atac_subset <- seurat_atac[,colnames(temp)]
seurat_atac_subset@meta.data <- temp@meta.data
rm(temp)

Idents(seurat_atac_subset) <- seurat_atac_subset$pseudotime_bins_10

seurat_atac_subset <- Footprint(
  seurat_atac_subset,
  motif.name = c("NKX2-2", "OLIG1", "OLIG2", "SOX4"),
  genome = BSgenome.Mmusculus.UCSC.mm10
)


p <- PlotFootprint(
  seurat_atac_subset,
  features = c("NKX2-2", "OLIG1", "OLIG2", "SOX4")
) + scale_fill_manual(values=plasma(10))


pdf(paste0(fig_dir, cur_celltype, '_', cur_group, '_test_footprints.pdf'), width=12, height=12)
p
dev.off()


```
